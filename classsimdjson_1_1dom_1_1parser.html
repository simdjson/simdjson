<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: simdjson::dom::parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logotiny.png"/></td>
  <td id="projectalign">
   <div id="projectname">simdjson<span id="projectnumber">&#160;4.0.7</span>
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsimdjson_1_1dom_1_1parser.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsimdjson_1_1dom_1_1parser-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simdjson::dom::parser Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A persistent document parser.  
 <a href="classsimdjson_1_1dom_1_1parser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dom_2parser_8h_source.html">parser.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a09370efac9e1b7d9b4a8349332e026c3" id="r_a09370efac9e1b7d9b4a8349332e026c3"><td class="memItemLeft" align="right" valign="top">simdjson_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a09370efac9e1b7d9b4a8349332e026c3">parser</a> (size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a8bfde4193783adef9c5f12dfc4da3bc0">max_capacity</a>=<a class="el" href="namespacesimdjson.html#ad0bad3783275be4012bd5cfd0327875a">SIMDJSON_MAXSIZE_BYTES</a>) <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:a09370efac9e1b7d9b4a8349332e026c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a JSON parser.  <br /></td></tr>
<tr class="separator:a09370efac9e1b7d9b4a8349332e026c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3c80565fe63857e2901c48e7bed64d" id="r_a3f3c80565fe63857e2901c48e7bed64d"><td class="memItemLeft" align="right" valign="top">simdjson_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a3f3c80565fe63857e2901c48e7bed64d">parser</a> (<a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp;&amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">other</a>) <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:a3f3c80565fe63857e2901c48e7bed64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take another parser's buffers and state.  <br /></td></tr>
<tr class="separator:a3f3c80565fe63857e2901c48e7bed64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b61dda345cef1feba7c4529dfe0259" id="r_af5b61dda345cef1feba7c4529dfe0259"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#af5b61dda345cef1feba7c4529dfe0259">operator=</a> (<a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp;&amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">other</a>) <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:af5b61dda345cef1feba7c4529dfe0259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take another parser's buffers and state.  <br /></td></tr>
<tr class="separator:af5b61dda345cef1feba7c4529dfe0259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb48211f320af02b58dc3d0505059844" id="r_aeb48211f320af02b58dc3d0505059844"><td class="memItemLeft" align="right" valign="top"><a id="aeb48211f320af02b58dc3d0505059844" name="aeb48211f320af02b58dc3d0505059844"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~parser</b> ()=<a class="el" href="classsimdjson_1_1dom_1_1array.html">default</a></td></tr>
<tr class="memdesc:aeb48211f320af02b58dc3d0505059844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the JSON parser. <br /></td></tr>
<tr class="separator:aeb48211f320af02b58dc3d0505059844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac408e4da66b0ac7cf9734aa4973e0093" id="r_ac408e4da66b0ac7cf9734aa4973e0093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#ac408e4da66b0ac7cf9734aa4973e0093">load</a> (std::string_view <a class="el" href="classsimdjson_1_1dom_1_1array.html">path</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:ac408e4da66b0ac7cf9734aa4973e0093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a JSON document from a file and return a reference to it.  <br /></td></tr>
<tr class="separator:ac408e4da66b0ac7cf9734aa4973e0093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133734a750f7ebb9d0b404d8b1b29555" id="r_a133734a750f7ebb9d0b404d8b1b29555"><td class="memItemLeft" align="right" valign="top"><a id="a133734a750f7ebb9d0b404d8b1b29555" name="a133734a750f7ebb9d0b404d8b1b29555"></a>
<a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>load</b> (std::string_view <a class="el" href="classsimdjson_1_1dom_1_1array.html">path</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:a133734a750f7ebb9d0b404d8b1b29555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fc69c5ff15c98e6b1ff9aa4811b040" id="r_aa3fc69c5ff15c98e6b1ff9aa4811b040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#aa3fc69c5ff15c98e6b1ff9aa4811b040">load_into_document</a> (<a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;doc, std::string_view <a class="el" href="classsimdjson_1_1dom_1_1array.html">path</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:aa3fc69c5ff15c98e6b1ff9aa4811b040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a JSON document from a file into a provide document instance and return a temporary reference to it.  <br /></td></tr>
<tr class="separator:aa3fc69c5ff15c98e6b1ff9aa4811b040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a22516522a2655e7f2fad1dfdc565c4" id="r_a2a22516522a2655e7f2fad1dfdc565c4"><td class="memItemLeft" align="right" valign="top"><a id="a2a22516522a2655e7f2fad1dfdc565c4" name="a2a22516522a2655e7f2fad1dfdc565c4"></a>
<a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>load_into_document</b> (<a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;doc, std::string_view <a class="el" href="classsimdjson_1_1dom_1_1array.html">path</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:a2a22516522a2655e7f2fad1dfdc565c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c7d1e28125ef7d5703244483f70984" id="r_a16c7d1e28125ef7d5703244483f70984"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a16c7d1e28125ef7d5703244483f70984">parse</a> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">uint8_t</a> *buf, size_t len, <a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">realloc_if_needed</a>=<a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:a16c7d1e28125ef7d5703244483f70984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a JSON document and return a temporary reference to it.  <br /></td></tr>
<tr class="separator:a16c7d1e28125ef7d5703244483f70984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad153df3c2740ce735665e302a768763c" id="r_ad153df3c2740ce735665e302a768763c"><td class="memItemLeft" align="right" valign="top"><a id="ad153df3c2740ce735665e302a768763c" name="ad153df3c2740ce735665e302a768763c"></a>
<a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">uint8_t</a> *buf, size_t len, <a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">realloc_if_needed</a>=<a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:ad153df3c2740ce735665e302a768763c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf358420cd2a1d1b60047cde61c074d5" id="r_adf358420cd2a1d1b60047cde61c074d5"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#adf358420cd2a1d1b60047cde61c074d5">parse</a> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">char</a> *buf, size_t len, <a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">realloc_if_needed</a>=<a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="separator:adf358420cd2a1d1b60047cde61c074d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8645a31356712ab164f8ce34e66f9a" id="r_abf8645a31356712ab164f8ce34e66f9a"><td class="memItemLeft" align="right" valign="top"><a id="abf8645a31356712ab164f8ce34e66f9a" name="abf8645a31356712ab164f8ce34e66f9a"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">char</a> *buf, size_t len, <a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">realloc_if_needed</a>=<a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:abf8645a31356712ab164f8ce34e66f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806cb2434fe8c5aca0426e446eaecd01" id="r_a806cb2434fe8c5aca0426e446eaecd01"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a806cb2434fe8c5aca0426e446eaecd01">parse</a> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> std::string &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="separator:a806cb2434fe8c5aca0426e446eaecd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4341b5c0c2bb88eed234794b6db84be" id="r_aa4341b5c0c2bb88eed234794b6db84be"><td class="memItemLeft" align="right" valign="top"><a id="aa4341b5c0c2bb88eed234794b6db84be" name="aa4341b5c0c2bb88eed234794b6db84be"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> std::string &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:aa4341b5c0c2bb88eed234794b6db84be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62aa4cdd077e243a72695c4e24535a5c" id="r_a62aa4cdd077e243a72695c4e24535a5c"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a62aa4cdd077e243a72695c4e24535a5c">parse</a> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="separator:a62aa4cdd077e243a72695c4e24535a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af2b2ec2d06f3cece0a7907a093d391" id="r_a3af2b2ec2d06f3cece0a7907a093d391"><td class="memItemLeft" align="right" valign="top"><a id="a3af2b2ec2d06f3cece0a7907a093d391" name="a3af2b2ec2d06f3cece0a7907a093d391"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:a3af2b2ec2d06f3cece0a7907a093d391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18ffd4e12e8fefd59d9be28a1703084" id="r_ad18ffd4e12e8fefd59d9be28a1703084"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#ad18ffd4e12e8fefd59d9be28a1703084">parse</a> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1padded__string__view.html">padded_string_view</a> &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">v</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="separator:ad18ffd4e12e8fefd59d9be28a1703084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdefb1c1b633103654b8a562fc497a90" id="r_afdefb1c1b633103654b8a562fc497a90"><td class="memItemLeft" align="right" valign="top"><a id="afdefb1c1b633103654b8a562fc497a90" name="afdefb1c1b633103654b8a562fc497a90"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1padded__string__view.html">padded_string_view</a> &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">v</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:afdefb1c1b633103654b8a562fc497a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afc4d3b429363b503a5605d66081e30" id="r_a1afc4d3b429363b503a5605d66081e30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a1afc4d3b429363b503a5605d66081e30">parse_into_document</a> (<a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;doc, <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">uint8_t</a> *buf, size_t len, <a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">realloc_if_needed</a>=<a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:a1afc4d3b429363b503a5605d66081e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a JSON document into a provide document instance and return a temporary reference to it.  <br /></td></tr>
<tr class="separator:a1afc4d3b429363b503a5605d66081e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f24255f994425efd56a1388412c35af" id="r_a3f24255f994425efd56a1388412c35af"><td class="memItemLeft" align="right" valign="top"><a id="a3f24255f994425efd56a1388412c35af" name="a3f24255f994425efd56a1388412c35af"></a>
<a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse_into_document</b> (<a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;doc, <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">uint8_t</a> *buf, size_t len, <a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">realloc_if_needed</a>=<a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:a3f24255f994425efd56a1388412c35af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94df57d3bf19ae8f1fd56c7e1c48aed4" id="r_a94df57d3bf19ae8f1fd56c7e1c48aed4"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a94df57d3bf19ae8f1fd56c7e1c48aed4">parse_into_document</a> (<a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;doc, <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">char</a> *buf, size_t len, <a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">realloc_if_needed</a>=<a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="separator:a94df57d3bf19ae8f1fd56c7e1c48aed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48389f580ff6a7a802274979b75554ed" id="r_a48389f580ff6a7a802274979b75554ed"><td class="memItemLeft" align="right" valign="top"><a id="a48389f580ff6a7a802274979b75554ed" name="a48389f580ff6a7a802274979b75554ed"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse_into_document</b> (<a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;doc, <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">char</a> *buf, size_t len, <a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">realloc_if_needed</a>=<a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:a48389f580ff6a7a802274979b75554ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ea845b2e155c985df803718369d0b4" id="r_a96ea845b2e155c985df803718369d0b4"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a96ea845b2e155c985df803718369d0b4">parse_into_document</a> (<a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;doc, <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> std::string &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="separator:a96ea845b2e155c985df803718369d0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e48918c7f2ded06bb1655431afc4bef" id="r_a3e48918c7f2ded06bb1655431afc4bef"><td class="memItemLeft" align="right" valign="top"><a id="a3e48918c7f2ded06bb1655431afc4bef" name="a3e48918c7f2ded06bb1655431afc4bef"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse_into_document</b> (<a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;doc, <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> std::string &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:a3e48918c7f2ded06bb1655431afc4bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b59cec3f7b7c755067c317ed0bfa12" id="r_ab4b59cec3f7b7c755067c317ed0bfa12"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#ab4b59cec3f7b7c755067c317ed0bfa12">parse_into_document</a> (<a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;doc, <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>) &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="separator:ab4b59cec3f7b7c755067c317ed0bfa12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb3749d7b08a3a8545eb289e9c32ee3" id="r_a7eb3749d7b08a3a8545eb289e9c32ee3"><td class="memItemLeft" align="right" valign="top"><a id="a7eb3749d7b08a3a8545eb289e9c32ee3" name="a7eb3749d7b08a3a8545eb289e9c32ee3"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse_into_document</b> (<a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;doc, <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>) &amp;&amp;=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:a7eb3749d7b08a3a8545eb289e9c32ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d839fa94a8a800814164f225d987d0a" id="r_a8d839fa94a8a800814164f225d987d0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a8d839fa94a8a800814164f225d987d0a">load_many</a> (std::string_view <a class="el" href="classsimdjson_1_1dom_1_1array.html">path</a>, size_t batch_size=dom::DEFAULT_BATCH_SIZE) <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:a8d839fa94a8a800814164f225d987d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a file containing many JSON documents.  <br /></td></tr>
<tr class="separator:a8d839fa94a8a800814164f225d987d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c658556dd9e9396e9ce44ba4b01f2d1" id="r_a5c658556dd9e9396e9ce44ba4b01f2d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a5c658556dd9e9396e9ce44ba4b01f2d1">parse_many</a> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">uint8_t</a> *buf, size_t len, size_t batch_size=dom::DEFAULT_BATCH_SIZE) <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:a5c658556dd9e9396e9ce44ba4b01f2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a buffer containing many JSON documents.  <br /></td></tr>
<tr class="separator:a5c658556dd9e9396e9ce44ba4b01f2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5a4be2a8660e6f22b99783bb94f690" id="r_a3a5a4be2a8660e6f22b99783bb94f690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a3a5a4be2a8660e6f22b99783bb94f690">parse_many</a> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">char</a> *buf, size_t len, size_t batch_size=dom::DEFAULT_BATCH_SIZE) <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="separator:a3a5a4be2a8660e6f22b99783bb94f690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720a2dd204322bcfcb5e9743ecf51da1" id="r_a720a2dd204322bcfcb5e9743ecf51da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a720a2dd204322bcfcb5e9743ecf51da1">parse_many</a> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> std::string &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>, size_t batch_size=dom::DEFAULT_BATCH_SIZE) <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="separator:a720a2dd204322bcfcb5e9743ecf51da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905603a77a71e79c243ea5f5bd51d778" id="r_a905603a77a71e79c243ea5f5bd51d778"><td class="memItemLeft" align="right" valign="top"><a id="a905603a77a71e79c243ea5f5bd51d778" name="a905603a77a71e79c243ea5f5bd51d778"></a>
<a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse_many</b> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> std::string &amp;&amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>, size_t batch_size)=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:a905603a77a71e79c243ea5f5bd51d778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7856c99cbf39d24cfc733babdd4ca416" id="r_a7856c99cbf39d24cfc733babdd4ca416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a7856c99cbf39d24cfc733babdd4ca416">parse_many</a> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>, size_t batch_size=dom::DEFAULT_BATCH_SIZE) <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="separator:a7856c99cbf39d24cfc733babdd4ca416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13525749822d714befcdc67f9bb04f9b" id="r_a13525749822d714befcdc67f9bb04f9b"><td class="memItemLeft" align="right" valign="top"><a id="a13525749822d714befcdc67f9bb04f9b" name="a13525749822d714befcdc67f9bb04f9b"></a>
<a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse_many</b> (<a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;&amp;<a class="el" href="classsimdjson_1_1dom_1_1array.html">s</a>, size_t batch_size)=<a class="el" href="classsimdjson_1_1dom_1_1array.html">delete</a></td></tr>
<tr class="separator:a13525749822d714befcdc67f9bb04f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f49755a335bc269cb02d24badfcdf9" id="r_af8f49755a335bc269cb02d24badfcdf9"><td class="memItemLeft" align="right" valign="top">simdjson_warn_unused <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#af8f49755a335bc269cb02d24badfcdf9">allocate</a> (size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#aedf495a6e090929be23473e8a29f2fe2">capacity</a>, size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#ab090f596cd0b0c1d34576fd6aae88ee5">max_depth</a>=<a class="el" href="namespacesimdjson.html#a6df2598eb1d4e1ea669c41831cc7325d">DEFAULT_MAX_DEPTH</a>) <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:af8f49755a335bc269cb02d24badfcdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure this parser has enough memory to process JSON documents up to <code>capacity</code> bytes in length and <code>max_depth</code> depth.  <br /></td></tr>
<tr class="separator:af8f49755a335bc269cb02d24badfcdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf495a6e090929be23473e8a29f2fe2" id="r_aedf495a6e090929be23473e8a29f2fe2"><td class="memItemLeft" align="right" valign="top">simdjson_inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#aedf495a6e090929be23473e8a29f2fe2">capacity</a> () <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:aedf495a6e090929be23473e8a29f2fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest document this parser can support without reallocating.  <br /></td></tr>
<tr class="separator:aedf495a6e090929be23473e8a29f2fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfde4193783adef9c5f12dfc4da3bc0" id="r_a8bfde4193783adef9c5f12dfc4da3bc0"><td class="memItemLeft" align="right" valign="top">simdjson_inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a8bfde4193783adef9c5f12dfc4da3bc0">max_capacity</a> () <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:a8bfde4193783adef9c5f12dfc4da3bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest document this parser can automatically support.  <br /></td></tr>
<tr class="separator:a8bfde4193783adef9c5f12dfc4da3bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab090f596cd0b0c1d34576fd6aae88ee5" id="r_ab090f596cd0b0c1d34576fd6aae88ee5"><td class="memItemLeft" align="right" valign="top">simdjson_pure simdjson_inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#ab090f596cd0b0c1d34576fd6aae88ee5">max_depth</a> () <a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:ab090f596cd0b0c1d34576fd6aae88ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum level of nested object and arrays supported by this parser.  <br /></td></tr>
<tr class="separator:ab090f596cd0b0c1d34576fd6aae88ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6977b4586bc601070cf100e2973a4cbc" id="r_a6977b4586bc601070cf100e2973a4cbc"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="classsimdjson_1_1dom_1_1array.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a6977b4586bc601070cf100e2973a4cbc">set_max_capacity</a> (size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a8bfde4193783adef9c5f12dfc4da3bc0">max_capacity</a>) <a class="el" href="classsimdjson_1_1dom_1_1array.html">noexcept</a></td></tr>
<tr class="memdesc:a6977b4586bc601070cf100e2973a4cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set max_capacity.  <br /></td></tr>
<tr class="separator:a6977b4586bc601070cf100e2973a4cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a63fe2363db0d3acf458519698beaacf4" id="r_a63fe2363db0d3acf458519698beaacf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a63fe2363db0d3acf458519698beaacf4">threaded</a> {<a class="el" href="classsimdjson_1_1dom_1_1array.html">false</a>}</td></tr>
<tr class="memdesc:a63fe2363db0d3acf458519698beaacf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">When SIMDJSON_THREADS_ENABLED is not defined, the parser instance cannot use threads.  <br /></td></tr>
<tr class="separator:a63fe2363db0d3acf458519698beaacf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A persistent document parser. </p>
<p>The parser is designed to be reused, holding the internal buffers necessary to do parsing, as well as memory for a single document. The parsed document is overwritten on each parse.</p>
<p>This class cannot be copied, only moved, to avoid unintended allocations.</p>
<dl class="section note"><dt>Note</dt><dd>Moving a parser instance may invalidate "dom::element" instances. If you need to preserve both the "dom::element" instances and the parser, consider wrapping the parser instance in a std::unique_ptr instance:</dd></dl>
<p>std::unique_ptr&lt;dom::parser&gt; parser(new <a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a>{}); auto error = parser-&gt;load(f).get(root);</p>
<p>You can then move std::unique_ptr safely.</p>
<dl class="section note"><dt>Note</dt><dd>This is not thread safe: one parser cannot produce two documents at the same time! </dd></dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser_8h_source.html#l00030">30</a> of file <a class="el" href="dom_2parser_8h_source.html">parser.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a09370efac9e1b7d9b4a8349332e026c3" name="a09370efac9e1b7d9b4a8349332e026c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09370efac9e1b7d9b4a8349332e026c3">&#9670;&#160;</a></span>parser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline simdjson::dom::parser::parser </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_capacity</em> = <code><a class="el" href="namespacesimdjson.html#ad0bad3783275be4012bd5cfd0327875a">SIMDJSON_MAXSIZE_BYTES</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a JSON parser. </p>
<p>The new parser will have zero capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_capacity</td><td>The maximum document length the parser can automatically handle. The parser will allocate more capacity on an as needed basis (when it sees documents too big to handle) up to this amount. The parser still starts with zero capacity no matter what this number is: to allocate an initial capacity, call <a class="el" href="classsimdjson_1_1dom_1_1parser.html#af8f49755a335bc269cb02d24badfcdf9" title="Ensure this parser has enough memory to process JSON documents up to capacity bytes in length and max...">allocate()</a> after constructing the parser. Defaults to SIMDJSON_MAXSIZE_BYTES (the largest single document simdjson can process). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00023">23</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a3f3c80565fe63857e2901c48e7bed64d" name="a3f3c80565fe63857e2901c48e7bed64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3c80565fe63857e2901c48e7bed64d">&#9670;&#160;</a></span>parser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline simdjson::dom::parser::parser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take another parser's buffers and state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The parser to take. Its capacity is zeroed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af8f49755a335bc269cb02d24badfcdf9" name="af8f49755a335bc269cb02d24badfcdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f49755a335bc269cb02d24badfcdf9">&#9670;&#160;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_warn_unused <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a> simdjson::dom::parser::allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_depth</em> = <code><a class="el" href="namespacesimdjson.html#a6df2598eb1d4e1ea669c41831cc7325d">DEFAULT_MAX_DEPTH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure this parser has enough memory to process JSON documents up to <code>capacity</code> bytes in length and <code>max_depth</code> depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The new capacity. </td></tr>
    <tr><td class="paramname">max_depth</td><td>The new max_depth. Defaults to DEFAULT_MAX_DEPTH. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error, if there is one. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00199">199</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="aedf495a6e090929be23473e8a29f2fe2" name="aedf495a6e090929be23473e8a29f2fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf495a6e090929be23473e8a29f2fe2">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline size_t simdjson::dom::parser::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The largest document this parser can support without reallocating. </p>
<dl class="section return"><dt>Returns</dt><dd>Current capacity, in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00188">188</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="ac408e4da66b0ac7cf9734aa4973e0093" name="ac408e4da66b0ac7cf9734aa4973e0093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac408e4da66b0ac7cf9734aa4973e0093">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::load </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a JSON document from a file and return a reference to it. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; const element doc = <a class="el" href="classsimdjson_1_1dom_1_1parser.html#ac408e4da66b0ac7cf9734aa4973e0093" title="Load a JSON document from a file and return a reference to it.">parser.load</a>("jsonexamples/twitter.json");</p>
<p>The function is eager: the file's content is loaded in memory inside the parser instance and immediately parsed. The file can be deleted after the <code><a class="el" href="classsimdjson_1_1dom_1_1parser.html#ac408e4da66b0ac7cf9734aa4973e0093" title="Load a JSON document from a file and return a reference to it.">parser.load</a></code> call.</p>
<h3><a class="anchor" id="autotoc_md132"></a>
IMPORTANT: Document Lifetime</h3>
<p>The JSON document still lives in the parser: this is the most efficient way to parse JSON documents because it reuses the same buffers, but you <em>must</em> use the document before you destroy the parser or call <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a16c7d1e28125ef7d5703244483f70984" title="Parse a JSON document and return a temporary reference to it.">parse()</a> again.</p>
<p>Moving the parser instance is safe, but it invalidates the element instances. You may store the parser instance without moving it by wrapping it inside an <code>unique_ptr</code> instance like so: <code>std::unique_ptr&lt;<a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a>&gt; parser(new <a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a>{});</code>.</p>
<h3><a class="anchor" id="autotoc_md133"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than the file length, it will allocate enough capacity to handle it (up to max_capacity).</p>
<h2><a class="anchor" id="autotoc_md134"></a>
Windows and Unicode</h2>
<p>Windows users who need to read files with non-ANSI characters in the name should set their code page to UTF-8 (65001) before calling this function. This should be the default with Windows 11 and better. Further, they may use the AreFileApisANSI function to determine whether the filename is interpreted using the ANSI or the system default OEM codepage, and they may call SetFileApisToOEM accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The document, or an error:<ul>
<li>IO_ERROR if there was an error opening or reading the file. Be mindful that on some 32-bit systems, the file size might be limited to 2 GB.</li>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and len &gt; max_capacity.</li>
<li>other json errors if parsing fails. You should not rely on these errors to always the same for the same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware). </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00094">94</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="aa3fc69c5ff15c98e6b1ff9aa4811b040" name="aa3fc69c5ff15c98e6b1ff9aa4811b040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fc69c5ff15c98e6b1ff9aa4811b040">&#9670;&#160;</a></span>load_into_document()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::load_into_document </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a JSON document from a file into a provide document instance and return a temporary reference to it. </p>
<p>It is similar to the function <code>load</code> except that instead of parsing into the internal <code>document</code> instance associated with the parser, it allows the user to provide a document instance.</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; <a class="el" href="classsimdjson_1_1dom_1_1document.html" title="A parsed JSON document.">dom::document</a> doc; element doc_root = <a class="el" href="classsimdjson_1_1dom_1_1parser.html#aa3fc69c5ff15c98e6b1ff9aa4811b040" title="Load a JSON document from a file into a provide document instance and return a temporary reference to...">parser.load_into_document</a>(doc, "jsonexamples/twitter.json");</p>
<p>The function is eager: the file's content is loaded in memory inside the parser instance and immediately parsed. The file can be deleted after the <code><a class="el" href="classsimdjson_1_1dom_1_1parser.html#aa3fc69c5ff15c98e6b1ff9aa4811b040" title="Load a JSON document from a file into a provide document instance and return a temporary reference to...">parser.load_into_document</a></code> call.</p>
<h3><a class="anchor" id="autotoc_md135"></a>
IMPORTANT: Document Lifetime</h3>
<p>After the call to load_into_document, the parser is no longer needed.</p>
<p>The JSON document lives in the document instance: you must keep the document instance alive while you navigate through it (i.e., used the returned value from load_into_document). You are encourage to reuse the document instance many times with new data to avoid reallocations:</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1document.html" title="A parsed JSON document.">dom::document</a> doc; element doc_root1 = <a class="el" href="classsimdjson_1_1dom_1_1parser.html#aa3fc69c5ff15c98e6b1ff9aa4811b040" title="Load a JSON document from a file into a provide document instance and return a temporary reference to...">parser.load_into_document</a>(doc, "jsonexamples/twitter.json"); //... doc_root1 is a pointer inside doc element doc_root2 = <a class="el" href="classsimdjson_1_1dom_1_1parser.html#aa3fc69c5ff15c98e6b1ff9aa4811b040" title="Load a JSON document from a file into a provide document instance and return a temporary reference to...">parser.load_into_document</a>(doc, "jsonexamples/twitter.json"); //... doc_root2 is a pointer inside doc // at this point doc_root1 is no longer safe</p>
<p>Moving the document instance is safe, but it invalidates the element instances. After moving a document, you can recover safe access to the document root with its <code>root()</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc</td><td>The document instance where the parsed data will be stored (on success). </td></tr>
    <tr><td class="paramname">path</td><td>The path to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The document, or an error:<ul>
<li>IO_ERROR if there was an error opening or reading the file. Be mindful that on some 32-bit systems, the file size might be limited to 2 GB.</li>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and len &gt; max_capacity.</li>
<li>other json errors if parsing fails. You should not rely on these errors to always the same for the same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware). </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00098">98</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a8d839fa94a8a800814164f225d987d0a" name="a8d839fa94a8a800814164f225d987d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d839fa94a8a800814164f225d987d0a">&#9670;&#160;</a></span>load_many()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt; simdjson::dom::parser::load_many </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>dom::DEFAULT_BATCH_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a file containing many JSON documents. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (const element doc : parser.load_many(path)) { cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<p>The file is loaded in memory and can be safely deleted after the <code>parser.load_many(path)</code> function has returned. The memory is held by the <code>parser</code> instance.</p>
<p>The function is lazy: it may be that no more than one JSON document at a time is parsed. And, possibly, no document many have been parsed when the <code>parser.load_many(path)</code> function returned.</p>
<p>If there is a UTF-8 BOM, the parser skips it.</p>
<h3><a class="anchor" id="autotoc_md141"></a>
Format</h3>
<p>The file must contain a series of one or more JSON documents, concatenated into a single buffer, separated by whitespace. It effectively parses until it has a fully valid document, then starts parsing the next document at that point. (It does this with more parallelism and lookahead than you might think, though.)</p>
<p>Documents that consist of an object or array may omit the whitespace between them, concatenating with no separator. documents that consist of a single primitive (i.e. documents that are not arrays or objects) MUST be separated with whitespace.</p>
<p>The documents must not exceed batch_size bytes (by default 1MB) or they will fail to parse. Setting batch_size to excessively large or excessively small values may impact negatively the performance.</p>
<h3><a class="anchor" id="autotoc_md142"></a>
Error Handling</h3>
<p>All errors are returned during iteration: if there is a global error such as memory allocation, it will be yielded as the first result. Iteration always stops after the first error.</p>
<p>As with all other simdjson methods, non-exception error handling is readily available through the same interface, requiring you to check the error before using the document:</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html" title="A forward-only stream of documents.">dom::document_stream</a> docs; auto error = parser.load_many(path).get(docs); if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); } for (auto doc : docs) { std::string_view title; if ((error = doc["title"].get(title)) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); } cout &lt;&lt; title &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md143"></a>
Threads</h3>
<p>When compiled with SIMDJSON_THREADS_ENABLED, this method will use a single thread under the hood to do some lookahead.</p>
<h3><a class="anchor" id="autotoc_md144"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than batch_size, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>File name pointing at the concatenated JSON to parse. </td></tr>
    <tr><td class="paramname">batch_size</td><td>The batch size to use. MUST be larger than the largest document. The sweet spot is cache-related: small enough to fit in cache, yet big enough to parse as many documents as possible in one tight loop. Defaults to 1MB (as simdjson::dom::DEFAULT_BATCH_SIZE), which has been a reasonable sweet spot in our tests. If you set the batch_size to a value smaller than simdjson::dom::MINIMAL_BATCH_SIZE (currently 32B), it will be replaced by simdjson::dom::MINIMAL_BATCH_SIZE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream, or an error. An empty input will yield 0 documents rather than an EMPTY error. Errors:<ul>
<li>IO_ERROR if there was an error opening or reading the file.</li>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and batch_size &gt; max_capacity.</li>
<li>other json errors if parsing fails. You should not rely on these errors to always the same for the same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware). </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00105">105</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a8bfde4193783adef9c5f12dfc4da3bc0" name="a8bfde4193783adef9c5f12dfc4da3bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfde4193783adef9c5f12dfc4da3bc0">&#9670;&#160;</a></span>max_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline size_t simdjson::dom::parser::max_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The largest document this parser can automatically support. </p>
<p>The parser may reallocate internal buffers as needed up to this amount.</p>
<dl class="section return"><dt>Returns</dt><dd>Maximum capacity, in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00191">191</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="ab090f596cd0b0c1d34576fd6aae88ee5" name="ab090f596cd0b0c1d34576fd6aae88ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab090f596cd0b0c1d34576fd6aae88ee5">&#9670;&#160;</a></span>max_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_pure simdjson_inline size_t simdjson::dom::parser::max_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum level of nested object and arrays supported by this parser. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum depth, in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00194">194</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="af5b61dda345cef1feba7c4529dfe0259" name="af5b61dda345cef1feba7c4529dfe0259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b61dda345cef1feba7c4529dfe0259">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp; simdjson::dom::parser::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take another parser's buffers and state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The parser to take. Its capacity is zeroed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf358420cd2a1d1b60047cde61c074d5" name="adf358420cd2a1d1b60047cde61c074d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf358420cd2a1d1b60047cde61c074d5">&#9670;&#160;</a></span>parse() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">char</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a>&#160;</td>
          <td class="paramname"><em>realloc_if_needed</em> = <code><a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00157">157</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a62aa4cdd077e243a72695c4e24535a5c" name="a62aa4cdd077e243a72695c4e24535a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62aa4cdd077e243a72695c4e24535a5c">&#9670;&#160;</a></span>parse() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00163">163</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="ad18ffd4e12e8fefd59d9be28a1703084" name="ad18ffd4e12e8fefd59d9be28a1703084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18ffd4e12e8fefd59d9be28a1703084">&#9670;&#160;</a></span>parse() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1padded__string__view.html">padded_string_view</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00166">166</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a806cb2434fe8c5aca0426e446eaecd01" name="a806cb2434fe8c5aca0426e446eaecd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806cb2434fe8c5aca0426e446eaecd01">&#9670;&#160;</a></span>parse() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00160">160</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a16c7d1e28125ef7d5703244483f70984" name="a16c7d1e28125ef7d5703244483f70984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c7d1e28125ef7d5703244483f70984">&#9670;&#160;</a></span>parse() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a>&#160;</td>
          <td class="paramname"><em>realloc_if_needed</em> = <code><a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a JSON document and return a temporary reference to it. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; element doc_root = parser.parse(buf, len);</p>
<p>The function eagerly parses the input: the input can be modified and discarded after the <code>parser.parse(buf, len)</code> call has completed.</p>
<h3><a class="anchor" id="autotoc_md136"></a>
IMPORTANT: Document Lifetime</h3>
<p>The JSON document still lives in the parser: this is the most efficient way to parse JSON documents because it reuses the same buffers, but you <em>must</em> use the document before you destroy the parser or call <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a16c7d1e28125ef7d5703244483f70984" title="Parse a JSON document and return a temporary reference to it.">parse()</a> again.</p>
<p>Moving the parser instance is safe, but it invalidates the element instances. You may store the parser instance without moving it by wrapping it inside an <code>unique_ptr</code> instance like so: <code>std::unique_ptr&lt;<a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a>&gt; parser(new <a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a>{});</code>.</p>
<h3><a class="anchor" id="autotoc_md137"></a>
REQUIRED: Buffer Padding</h3>
<p>The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated. These bytes will be read: if you using a sanitizer that verifies that no uninitialized byte is read, then you should initialize the SIMDJSON_PADDING bytes to avoid runtime warnings.</p>
<p>If realloc_if_needed is true (the default), it is assumed that the buffer does <em>not</em> have enough padding, and it is copied into an enlarged temporary buffer before parsing. Thus the following is safe:</p>
<p>const char *json = R"({"key":"value"})"; const size_t json_len = std::strlen(json); <a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">simdjson::dom::parser</a> parser; <a class="el" href="classsimdjson_1_1dom_1_1element.html" title="A JSON element.">simdjson::dom::element</a> element = parser.parse(json, json_len);</p>
<p>If you set realloc_if_needed to false (e.g., parser.parse(json, json_len, false)), you must provide a buffer with at least SIMDJSON_PADDING extra bytes at the end. The benefit of setting realloc_if_needed to false is that you avoid a temporary memory allocation and a copy.</p>
<p>The padded bytes may be read. It is not important how you initialize these bytes though we recommend a sensible default like null character values or spaces. For example, the following low-level code is safe:</p>
<p>const char *json = R"({"key":"value"})"; const size_t json_len = std::strlen(json); std::unique_ptr&lt;char[]&gt; padded_json_copy{new char[json_len + SIMDJSON_PADDING]}; std::memcpy(padded_json_copy.get(), json, json_len); std::memset(padded_json_copy.get() + json_len, '\0', SIMDJSON_PADDING); <a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">simdjson::dom::parser</a> parser; <a class="el" href="classsimdjson_1_1dom_1_1element.html" title="A JSON element.">simdjson::dom::element</a> element = <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a16c7d1e28125ef7d5703244483f70984" title="Parse a JSON document and return a temporary reference to it.">parser.parse</a>(padded_json_copy.get(), json_len, false);</p>
<h3><a class="anchor" id="autotoc_md138"></a>
std::string references</h3>
<p>If you pass a mutable std::string reference (std::string&amp;), the parser will seek to extend its capacity to SIMDJSON_PADDING bytes beyond the end of the string.</p>
<p>Whenever you pass an std::string reference, the parser will access the bytes beyond the end of the string but before the end of the allocated memory (std::string::capacity()). If you are using a sanitizer that checks for reading uninitialized bytes or std::string's container-overflow checks, you may encounter sanitizer warnings. You can safely ignore these warnings. Or you can call <a class="el" href="namespacesimdjson.html#ac4131fd8cef9c8046d0bc9aee8d44d16" title="Create a padded_string_view from a string.">simdjson::pad(std::string&amp;)</a> to pad the string with SIMDJSON_PADDING spaces: this function returns a simdjson::padding_string_view which can be be passed to the parser's parse function:</p>
<p>std::string json = R"({ "foo": 1 } { "foo": 2 } { "foo": 3 } )"; element doc = parser.parse(simdjson::pad(json));</p>
<h3><a class="anchor" id="autotoc_md139"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than len, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The JSON to parse. Must have at least len + SIMDJSON_PADDING allocated bytes, unless realloc_if_needed is true. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the JSON. </td></tr>
    <tr><td class="paramname">realloc_if_needed</td><td>Whether to reallocate and enlarge the JSON buffer to add padding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An element pointing at the root of the document, or an error:<ul>
<li>MEMALLOC if realloc_if_needed is true or the parser does not have enough capacity, and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and len &gt; max_capacity.</li>
<li>other json errors if parsing fails. You should not rely on these errors to always the same for the same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware). </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00153">153</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a94df57d3bf19ae8f1fd56c7e1c48aed4" name="a94df57d3bf19ae8f1fd56c7e1c48aed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94df57d3bf19ae8f1fd56c7e1c48aed4">&#9670;&#160;</a></span>parse_into_document() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse_into_document </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">char</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a>&#160;</td>
          <td class="paramname"><em>realloc_if_needed</em> = <code><a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00142">142</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="ab4b59cec3f7b7c755067c317ed0bfa12" name="ab4b59cec3f7b7c755067c317ed0bfa12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b59cec3f7b7c755067c317ed0bfa12">&#9670;&#160;</a></span>parse_into_document() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse_into_document </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00148">148</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a96ea845b2e155c985df803718369d0b4" name="a96ea845b2e155c985df803718369d0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ea845b2e155c985df803718369d0b4">&#9670;&#160;</a></span>parse_into_document() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse_into_document </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00145">145</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a1afc4d3b429363b503a5605d66081e30" name="a1afc4d3b429363b503a5605d66081e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afc4d3b429363b503a5605d66081e30">&#9670;&#160;</a></span>parse_into_document() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse_into_document </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> &amp;&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a>&#160;</td>
          <td class="paramname"><em>realloc_if_needed</em> = <code><a class="el" href="classsimdjson_1_1dom_1_1array.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a JSON document into a provide document instance and return a temporary reference to it. </p>
<p>It is similar to the function <code>parse</code> except that instead of parsing into the internal <code>document</code> instance associated with the parser, it allows the user to provide a document instance.</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; <a class="el" href="classsimdjson_1_1dom_1_1document.html" title="A parsed JSON document.">dom::document</a> doc; element doc_root = parser.parse_into_document(doc, buf, len);</p>
<p>The function eagerly parses the input: the input can be modified and discarded after the <code>parser.parse(buf, len)</code> call has completed.</p>
<h3><a class="anchor" id="autotoc_md140"></a>
IMPORTANT: Document Lifetime</h3>
<p>After the call to parse_into_document, the parser is no longer needed.</p>
<p>The JSON document lives in the document instance: you must keep the document instance alive while you navigate through it (i.e., used the returned value from parse_into_document). You are encourage to reuse the document instance many times with new data to avoid reallocations:</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1document.html" title="A parsed JSON document.">dom::document</a> doc; element doc_root1 = parser.parse_into_document(doc, buf1, len); //... doc_root1 is a pointer inside doc element doc_root2 = parser.parse_into_document(doc, buf1, len); //... doc_root2 is a pointer inside doc // at this point doc_root1 is no longer safe</p>
<p>Moving the document instance is safe, but it invalidates the element instances. After moving a document, you can recover safe access to the document root with its <code>root()</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc</td><td>The document instance where the parsed data will be stored (on success). </td></tr>
    <tr><td class="paramname">buf</td><td>The JSON to parse. Must have at least len + SIMDJSON_PADDING allocated bytes, unless realloc_if_needed is true. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the JSON. </td></tr>
    <tr><td class="paramname">realloc_if_needed</td><td>Whether to reallocate and enlarge the JSON buffer to add padding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An element pointing at the root of document, or an error:<ul>
<li>MEMALLOC if realloc_if_needed is true or the parser does not have enough capacity, and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and len &gt; max_capacity.</li>
<li>other json errors if parsing fails. You should not rely on these errors to always the same for the same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware). </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00113">113</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a3a5a4be2a8660e6f22b99783bb94f690" name="a3a5a4be2a8660e6f22b99783bb94f690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5a4be2a8660e6f22b99783bb94f690">&#9670;&#160;</a></span>parse_many() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt; simdjson::dom::parser::parse_many </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">char</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>dom::DEFAULT_BATCH_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00178">178</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a7856c99cbf39d24cfc733babdd4ca416" name="a7856c99cbf39d24cfc733babdd4ca416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7856c99cbf39d24cfc733babdd4ca416">&#9670;&#160;</a></span>parse_many() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt; simdjson::dom::parser::parse_many </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>dom::DEFAULT_BATCH_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00184">184</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a720a2dd204322bcfcb5e9743ecf51da1" name="a720a2dd204322bcfcb5e9743ecf51da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720a2dd204322bcfcb5e9743ecf51da1">&#9670;&#160;</a></span>parse_many() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> &gt; simdjson::dom::parser::parse_many </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>dom::DEFAULT_BATCH_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00181">181</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a5c658556dd9e9396e9ce44ba4b01f2d1" name="a5c658556dd9e9396e9ce44ba4b01f2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c658556dd9e9396e9ce44ba4b01f2d1">&#9670;&#160;</a></span>parse_many() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson::SIMDJSON_IMPLEMENTATION::ondemand::parser::parse_many </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1array.html">const</a> <a class="el" href="classsimdjson_1_1dom_1_1array.html">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>dom::DEFAULT_BATCH_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a buffer containing many JSON documents. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (element doc : parser.parse_many(buf, len)) { cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<p>No copy of the input buffer is made.</p>
<p>The function is lazy: it may be that no more than one JSON document at a time is parsed. And, possibly, no document many have been parsed when the <code>parser.load_many(path)</code> function returned.</p>
<p>The caller is responsabile to ensure that the input string data remains unchanged and is not deleted during the loop. In particular, the following is unsafe and will not compile:</p>
<p>auto docs = <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a5c658556dd9e9396e9ce44ba4b01f2d1" title="Parse a buffer containing many JSON documents.">parser.parse_many</a>("[\"temporary data\"]"_padded); // here the string "[\"temporary data\"]" may no longer exist in memory // the parser instance may not have even accessed the input yet for (element doc : docs) { cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<p>The following is safe:</p>
<p>auto json = "[\"temporary data\"]"_padded; auto docs = parser.parse_many(json); for (element doc : docs) { cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<p>If there is a UTF-8 BOM, the parser skips it.</p>
<h3><a class="anchor" id="autotoc_md145"></a>
Format</h3>
<p>The buffer must contain a series of one or more JSON documents, concatenated into a single buffer, separated by whitespace. It effectively parses until it has a fully valid document, then starts parsing the next document at that point. (It does this with more parallelism and lookahead than you might think, though.)</p>
<p>documents that consist of an object or array may omit the whitespace between them, concatenating with no separator. documents that consist of a single primitive (i.e. documents that are not arrays or objects) MUST be separated with whitespace.</p>
<p>The documents must not exceed batch_size bytes (by default 1MB) or they will fail to parse. Setting batch_size to excessively large or excessively small values may impact negatively the performance.</p>
<h3><a class="anchor" id="autotoc_md146"></a>
Error Handling</h3>
<p>All errors are returned during iteration: if there is a global error such as memory allocation, it will be yielded as the first result. Iteration always stops after the first error.</p>
<p>As with all other simdjson methods, non-exception error handling is readily available through the same interface, requiring you to check the error before using the document:</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; <a class="el" href="classsimdjson_1_1dom_1_1document__stream.html" title="A forward-only stream of documents.">dom::document_stream</a> docs; auto error = parser.load_many(path).get(docs); if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); } for (auto doc : docs) { std::string_view title; if ((error = doc["title"].get(title)) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); } cout &lt;&lt; title &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md147"></a>
REQUIRED: Buffer Padding</h3>
<p>The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated. These bytes will be read: if you using a sanitizer that verifies that no uninitialized byte is read, then you should initialize the SIMDJSON_PADDING bytes to avoid runtime warnings.</p>
<h3><a class="anchor" id="autotoc_md148"></a>
Threads</h3>
<p>When compiled with SIMDJSON_THREADS_ENABLED, this method will use a single thread under the hood to do some lookahead.</p>
<h3><a class="anchor" id="autotoc_md149"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than batch_size, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The concatenated JSON to parse. Must have at least len + SIMDJSON_PADDING allocated bytes. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the concatenated JSON. </td></tr>
    <tr><td class="paramname">batch_size</td><td>The batch size to use. MUST be larger than the largest document. The sweet spot is cache-related: small enough to fit in cache, yet big enough to parse as many documents as possible in one tight loop. Defaults to 10MB, which has been a reasonable sweet spot in our tests. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream, or an error. An empty input will yield 0 documents rather than an EMPTY error. Errors:<ul>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails</li>
<li>CAPACITY if the parser does not have enough capacity and batch_size &gt; max_capacity.</li>
<li>other json errors if parsing fails. You should not rely on these errors to always the same for the same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware).</li>
</ul>
</dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00170">170</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<a id="a6977b4586bc601070cf100e2973a4cbc" name="a6977b4586bc601070cf100e2973a4cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6977b4586bc601070cf100e2973a4cbc">&#9670;&#160;</a></span>set_max_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="classsimdjson_1_1dom_1_1array.html">void</a> simdjson::dom::parser::set_max_capacity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set max_capacity. </p>
<p>This is the largest document this parser can automatically support.</p>
<p>The parser may reallocate internal buffers as needed up to this amount as documents are passed to it.</p>
<p>Note: To avoid limiting the memory to an absurd value, such as zero or two bytes, iff you try to set max_capacity to a value lower than MINIMAL_DOCUMENT_CAPACITY, then the maximal capacity is set to MINIMAL_DOCUMENT_CAPACITY.</p>
<p>This call will not allocate or deallocate, even if capacity is currently above max_capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_capacity</td><td>The new maximum capacity, in bytes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dom_2parser-inl_8h_source.html#l00247">247</a> of file <a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a63fe2363db0d3acf458519698beaacf4" name="a63fe2363db0d3acf458519698beaacf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fe2363db0d3acf458519698beaacf4">&#9670;&#160;</a></span>threaded</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimdjson_1_1dom_1_1array.html">bool</a> simdjson::dom::parser::threaded {<a class="el" href="classsimdjson_1_1dom_1_1array.html">false</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When SIMDJSON_THREADS_ENABLED is not defined, the parser instance cannot use threads. </p>

<p class="definition">Definition at line <a class="el" href="dom_2parser_8h_source.html#l00575">575</a> of file <a class="el" href="dom_2parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/simdjson/dom/<a class="el" href="dom_2parser_8h_source.html">parser.h</a></li>
<li>include/simdjson/dom/<a class="el" href="dom_2parser-inl_8h_source.html">parser-inl.h</a></li>
<li>include/simdjson/dom/<a class="el" href="dom_2serialization-inl_8h_source.html">serialization-inl.h</a></li>
<li>include/simdjson/generic/ondemand/<a class="el" href="generic_2ondemand_2parser_8h_source.html">parser.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimdjson.html">simdjson</a></li><li class="navelem"><a class="el" href="namespacesimdjson_1_1dom.html">dom</a></li><li class="navelem"><a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
