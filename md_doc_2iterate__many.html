<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: iterate_many</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logotiny.png"/></td>
  <td id="projectalign">
   <div id="projectname">simdjson<span id="projectnumber">&#160;4.0.7</span>
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doc_2iterate__many.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">iterate_many</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>When serializing large databases, it is often better to write out many independent JSON documents, instead of one large monolithic document containing many records. The simdjson library provides high-speed access to files or streams containing multiple small JSON documents separated by ASCII white-space characters. Given an input such as </p><div class="fragment"><div class="line">{&quot;text&quot;:&quot;a&quot;}</div>
<div class="line">{&quot;text&quot;:&quot;b&quot;}</div>
<div class="line">{&quot;text&quot;:&quot;c&quot;}</div>
<div class="line">...</div>
</div><!-- fragment --><p> ... you want to read the entries (individual JSON documents) as quickly and as conveniently as possible. Importantly, the input might span several gigabytes, but you want to use a small (fixed) amount of memory. Ideally, you'd also like the parallelize the processing (using more than one core) to speed up the process.</p>
<h1><a class="anchor" id="autotoc_md75"></a>
Contents</h1>
<ul>
<li>Motivations</li>
<li>How it works<ul>
<li>Context</li>
<li>Design</li>
<li>Threads</li>
</ul>
</li>
<li>Support</li>
<li>API</li>
<li>Use cases</li>
<li>Tracking your position</li>
<li>Incomplete streams</li>
<li>C++20 features</li>
</ul>
<h1><a class="anchor" id="autotoc_md76"></a>
Motivation</h1>
<p>The main motivation for this piece of software is to achieve maximum speed and offer a better quality of life in parsing files containing multiple small JSON documents.</p>
<p>The JavaScript Object Notation (JSON) <a href="https://tools.ietf.org/html/rfc7159">RFC7159</a> is a handy serialization format. However, when serializing a large sequence of values as an array, or a possibly indeterminate-length or never- ending sequence of values, JSON may be inconvenient.</p>
<p>Consider a sequence of one million values, each possibly one kilobyte when encoded &ndash; roughly one gigabyte. It is often desirable to process such a dataset incrementally without having to first read all of it before beginning to produce results.</p>
<h1><a class="anchor" id="autotoc_md77"></a>
How it works</h1>
<h2><a class="anchor" id="autotoc_md78"></a>
Context</h2>
<p>Before parsing anything, simdjson first preprocesses the JSON text by identifying all structural indexes (i.e. the starting position of any JSON value, as well as any important operators like <code>,</code>, <code>:</code>, <code>]</code> or <code>}</code>) and validating UTF8. This stage is referred to stage 1. However, during this process, simdjson has no knowledge of whether parsed a valid document, multiple documents, or even if the document is complete. Then, to iterate through the JSON text during parsing, we use what we call a JSON iterator that will navigate through the text using these structural indexes. This JSON iterator is not visible though, but it is the key component to make parsing work.</p>
<p>Prior to iterate_many, most people who had to parse a multiline JSON file would proceed by reading the file line by line, using a utility function like <code>std::getline</code> or equivalent, and would then use the <code>parse</code> on each of those lines. From a performance point of view, this process is highly inefficient, in that it requires a lot of unnecessary memory allocation and makes use of the <code>getline</code> function, which is fundamentally slow, slower than the act of parsing with simdjson <a href="https://lemire.me/blog/2019/06/18/how-fast-is-getline-in-c/">(more on this here)</a>.</p>
<p>Unlike the popular parser RapidJson, our DOM does not require the buffer once the parsing job is completed, the DOM and the buffer are completely independent. The drawback of this architecture is that we need to allocate some additional memory to store our ParsedJson data, for every document inside a given file. Memory allocation can be slow and become a bottleneck, therefore, we want to minimize it as much as possible.</p>
<h2><a class="anchor" id="autotoc_md79"></a>
Design</h2>
<p>To achieve a minimum amount of allocations, we opted for a design where we create only one parser object and therefore allocate its memory once, and then recycle it for every document in a given file. But, knowing that they often have largely varying size, we need to make sure that we allocate enough memory so that all the documents can fit. This value is what we call the batch size. As of right now, we need to manually specify a value for this batch size, it has to be at least as big as the biggest document in your file, but not too big so that it submerges the cached memory. The bigger the batch size, the fewer we need to make allocations. We found that 1MB is somewhat a sweet spot.</p>
<ol type="1">
<li>When the user calls <code>iterate_many</code>, we return a <code>document_stream</code> which the user can iterate over to receive parsed documents.</li>
<li>We call stage 1 on the first batch_size bytes of JSON in the buffer, detecting structural indexes for all documents in that batch.</li>
<li>The <code>document_stream</code> owns a <code>document</code> instance that keeps track of the current document position in the stream using a JSON iterator. To obtain a valid document, the <code>document_stream</code> returns a <b>reference</b> to its document instance.</li>
<li>Each time the user calls <code>++</code> to read the next document, the JSON iterator moves to the start the next document.</li>
<li>When we reach the end of the batch, we call stage 1 on the next batch, starting from the end of the last document, and go to step 3.</li>
</ol>
<h2><a class="anchor" id="autotoc_md80"></a>
Threads</h2>
<p>But how can we make use of threads if they are available? We found a pretty cool algorithm that allows us to quickly identify the position of the last JSON document in a given batch. Knowing exactly where the end of the last document in the batch is, we can safely parse through the last document without any worries that it might be incomplete. Therefore, we can run stage 1 on the next batch concurrently while parsing the documents in the current batch. Running stage 1 in a different thread can, in best cases, remove almost entirely its cost and replaces it by the overhead of a thread, which is orders of magnitude cheaper. Ain't that awesome!</p>
<p>Thread support is only active if thread supported is detected in which case the macro SIMDJSON_THREADS_ENABLED is set. You can also manually pass <code>SIMDJSON_THREADS_ENABLED=1</code> flag to the library. Otherwise the library runs in single-thread mode.</p>
<p>You should be consistent. If you link against the simdjson library built for multithreading (i.e., with <code>SIMDJSON_THREADS_ENABLED</code>), then you should build your application with multithreading system (setting <code>SIMDJSON_THREADS_ENABLED=1</code> and linking against a thread library).</p>
<p>A <code>document_stream</code> instance uses at most two threads: there is a main thread and a worker thread.</p>
<h1><a class="anchor" id="autotoc_md81"></a>
Support</h1>
<p>Since we want to offer flexibility and not restrict ourselves to a specific file format, we support any file that contains any amount of valid JSON document, <b>separated by one or more character that is considered whitespace</b> by the JSON spec. Anything that is not whitespace will be parsed as a JSON document and could lead to failure.</p>
<p>Whitespace Characters:</p><ul>
<li><b>Space</b></li>
<li><b>Linefeed</b></li>
<li><b>Carriage return</b></li>
<li><b>Horizontal tab</b></li>
</ul>
<p>If your documents are all objects or arrays, then you may even have nothing between them. E.g., <code>[1,2]{"32":1}</code> is recognized as two documents.</p>
<p>Some official formats **(non-exhaustive list)**:</p><ul>
<li><a href="https://github.com/ndjson/ndjson-spec/">Newline-Delimited JSON (NDJSON)</a></li>
<li><a href="http://jsonlines.org/">JSON lines (JSONL)</a></li>
<li><a href="https://tools.ietf.org/html/rfc7464">Record separator-delimited JSON (RFC 7464)</a> &lt;- Not supported by JsonStream!</li>
<li><a href="https://en.wikipedia.org/wiki/JSON_streaming">More on Wikipedia...</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md82"></a>
API</h1>
<p>Example:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> json = R<span class="stringliteral">&quot;({ &quot;foo&quot;: 1 } { &quot;foo&quot;: 2 } { &quot;foo&quot;: 3 } )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">ondemand::parser parser;</span></div>
<div class="line"><span class="stringliteral">ondemand::document_stream docs = parser.iterate_many(json);</span></div>
<div class="line"><span class="stringliteral"></span><span class="keywordflow">for</span> (<span class="keyword">auto</span> doc : docs) {</div>
<div class="line">  std::cout &lt;&lt; doc[<span class="stringliteral">&quot;foo&quot;</span>] &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Prints 1 2 3</span></div>
</div><!-- fragment --><p>See <a href="basics.md#newline-delimited-json-ndjson-and-json-lines">basics.md</a> for an overview of the API.</p>
<h1><a class="anchor" id="autotoc_md83"></a>
Use cases</h1>
<p>From <a href="http://jsonlines.org/examples/">jsonlines.org</a>:</p>
<ul>
<li><p class="startli"><b>Better than CSV</b> </p><div class="fragment"><div class="line">[&quot;Name&quot;, &quot;Session&quot;, &quot;Score&quot;, &quot;Completed&quot;]</div>
<div class="line">[&quot;Gilbert&quot;, &quot;2013&quot;, 24, true]</div>
<div class="line">[&quot;Alexa&quot;, &quot;2013&quot;, 29, true]</div>
<div class="line">[&quot;May&quot;, &quot;2012B&quot;, 14, false]</div>
<div class="line">[&quot;Deloise&quot;, &quot;2012A&quot;, 19, true]</div>
</div><!-- fragment --><p> CSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.</p>
<p class="startli">JSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.</p>
<p class="startli">The biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.</p>
</li>
<li><b>Easy Nested Data</b> <div class="fragment"><div class="line">{&quot;name&quot;: &quot;Gilbert&quot;, &quot;wins&quot;: [[&quot;straight&quot;, &quot;7♣&quot;], [&quot;one pair&quot;, &quot;10♥&quot;]]}</div>
<div class="line">{&quot;name&quot;: &quot;Alexa&quot;, &quot;wins&quot;: [[&quot;two pair&quot;, &quot;4♠&quot;], [&quot;two pair&quot;, &quot;9♠&quot;]]}</div>
<div class="line">{&quot;name&quot;: &quot;May&quot;, &quot;wins&quot;: []}</div>
<div class="line">{&quot;name&quot;: &quot;Deloise&quot;, &quot;wins&quot;: [[&quot;three of a kind&quot;, &quot;5♣&quot;]]}</div>
</div><!-- fragment --> JSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.</li>
</ul>
<h1><a class="anchor" id="autotoc_md84"></a>
Tracking your position</h1>
<p>Some users would like to know where the document they parsed is in the input array of bytes. It is possible to do so by accessing directly the iterator and calling its <code>current_index()</code> method which reports the location (in bytes) of the current document in the input stream. You may also call the <code>source()</code> method to get a <code>std::string_view</code> instance on the document and <code>error()</code> to check if there were any error.</p>
<p>Let us illustrate the idea with code:</p>
<div class="fragment"><div class="line">++</div>
<div class="line">   <span class="keyword">auto</span> json = R<span class="stringliteral">&quot;([1,2,3]  {&quot;1&quot;:1,&quot;2&quot;:3,&quot;4&quot;:4} [1,2,3]  )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">   simdjson::ondemand::parser parser;</span></div>
<div class="line"><span class="stringliteral">   simdjson::ondemand::document_stream stream;</span></div>
<div class="line"><span class="stringliteral">   </span><span class="keyword">auto</span> error = parser.iterate_many(json).get(stream);</div>
<div class="line">   <span class="keywordflow">if</span> (error) { <span class="comment">/* do something */</span> }</div>
<div class="line">   <span class="keyword">auto</span> i = stream.begin();</div>
<div class="line">    <span class="keywordtype">size_t</span> count{0};</div>
<div class="line">   <span class="keywordflow">for</span>(; i != stream.end(); ++i) {</div>
<div class="line">       <span class="keyword">auto</span> doc = *i;</div>
<div class="line">       <span class="keywordflow">if</span> (!i.error()) {</div>
<div class="line">         std::cout &lt;&lt; <span class="stringliteral">&quot;got full document at &quot;</span> &lt;&lt; i.current_index() &lt;&lt; std::endl;</div>
<div class="line">         std::cout &lt;&lt; i.source() &lt;&lt; std::endl;</div>
<div class="line">         count++;</div>
<div class="line">       } <span class="keywordflow">else</span> {</div>
<div class="line">         std::cout &lt;&lt; <span class="stringliteral">&quot;got broken document at &quot;</span> &lt;&lt; i.current_index() &lt;&lt; std::endl;</div>
<div class="line">         <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">       }</div>
<div class="line">   }</div>
</div><!-- fragment --><p>This code will print: </p><div class="fragment"><div class="line">got full document at 0</div>
<div class="line">[1,2,3]</div>
<div class="line">got full document at 9</div>
<div class="line">{&quot;1&quot;:1,&quot;2&quot;:3,&quot;4&quot;:4}</div>
<div class="line">got full document at 29</div>
<div class="line">[1,2,3]</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md85"></a>
Incomplete streams</h1>
<p>Some users may need to work with truncated streams. The simdjson may truncate documents at the very end of the stream that cannot possibly be valid JSON (e.g., they contain unclosed strings, unmatched brackets, unmatched braces). After iterating through the stream, you may query the <code>truncated_bytes()</code> method which tells you how many bytes were truncated. If the stream is made of full (whole) documents, then you should expect <code>truncated_bytes()</code> to return zero.</p>
<p>Consider the following example where a truncated document (<code>{"key":"intentionally unclosed string&lt;/tt&gt;) containing 39 bytes has been left within the stream. In such cases, the first two whole documents are parsed and returned, and the &lt;tt&gt;truncated_bytes()&lt;/tt&gt; method returns 39.

@icode{C} ++
    auto json = R"([1,2,3] {"1":1,"2":3,"4":4} {"key":"intentionally unclosed string  )"_padded; simdjson::ondemand::parser parser; simdjson::ondemand::document_stream stream; auto error = parser.iterate_many(json,json.size()).get(stream); if (error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return; } for(auto i = stream.begin(); i != stream.end(); ++i) { std::cout &lt;&lt; i.source() &lt;&lt; std::endl; } std::cout &lt;&lt; stream.truncated_bytes() &lt;&lt; " bytes "&lt;&lt; std::endl; // returns 39 bytes </code></p>
<p><code>This will print: </p><div class="fragment"><div class="line">[1,2,3]</div>
<div class="line">{&quot;1&quot;:1,&quot;2&quot;:3,&quot;4&quot;:4}</div>
<div class="line">39 bytes</div>
</div><!-- fragment --><p></code></p>
<p><code>Importantly, you should only call <code>truncated_bytes()</code> after iterating through all of the documents since the stream cannot tell whether there are truncated documents at the very end when it may not have accessed that part of the data yet.</code></p>
<p><code></code></p>
<h1><a class="anchor" id="autotoc_md86"></a>
Comma-separated documents</h1>
<p><code></code></p>
<p><code>We also support comma-separated documents, but with some performance limitations. The <code>iterate_many</code> function takes in an option to allow parsing of comma separated documents (which defaults on false). In this mode, the entire buffer is processed in one batch. Therefore, the total size of the document should not exceed the maximal capacity of the parser (4 GB). This mode also effectively disallow multithreading. It is therefore mostly suitable for not "very large" inputs. In this mode, the batch_size parameter is effectively ignored, as it is set to at least the document size.</code></p>
<p><code>Example:</code></p>
<p><code></p><div class="fragment"><div class="line">++</div>
<div class="line">   <span class="keyword">auto</span> json = R<span class="stringliteral">&quot;( 1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, {&quot;hello&quot;: &quot;world&quot;} , [1, 2, 3])&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">   ondemand::parser parser;</span></div>
<div class="line"><span class="stringliteral">   ondemand::document_stream doc_stream;</span></div>
<div class="line"><span class="stringliteral">   </span><span class="comment">// We pass &#39;32&#39; as the batch size, but it is a bogus parameter because, since</span></div>
<div class="line">   <span class="comment">// we pass &#39;true&#39; to the allow_comma parameter, the batch size will be set to at least</span></div>
<div class="line">   <span class="comment">// the document size.</span></div>
<div class="line">   <span class="keyword">auto</span> error = parser.iterate_many(json, 32, <span class="keyword">true</span>).get(doc_stream);</div>
<div class="line">   <span class="keywordflow">if</span> (error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; <span class="keywordflow">return</span>; }</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keyword">auto</span> doc : doc_stream) {</div>
<div class="line">       std::cout &lt;&lt; doc.type() &lt;&lt; std::endl;</div>
<div class="line">   }</div>
</div><!-- fragment --><p></code></p>
<p><code> This will print:</code></p>
<p><code></p><div class="fragment"><div class="line">number</div>
<div class="line">number</div>
<div class="line">number</div>
<div class="line">number</div>
<div class="line">string</div>
<div class="line">string</div>
<div class="line">string</div>
<div class="line">object</div>
<div class="line">array</div>
</div><!-- fragment --><p></code></p>
<p><code></code></p>
<h1><a class="anchor" id="autotoc_md87"></a>
C++20 features</h1>
<p><code></code></p>
<p><code>In C++20, the standard introduced the notion of <em>customization point</em>. A customization point is a function or function object that can be customized for different types. It allows library authors to provide default behavior while giving users the ability to override this behavior for specific types.</code></p>
<p><code>A tag_invoke function serves as a mechanism for customization points. It is not directly part of the C++ standard library but is often used in libraries that implement customization points. The tag_invoke function is typically a generic function that takes a tag type and additional arguments. The first argument is usually a tag type (often an empty struct) that uniquely identifies the customization point (e.g., deserialization of custom types in simdjson). Users or library providers can specialize tag_invoke for their types by defining it in the appropriate namespace, often inline namespace.</code></p>
<p><code>You can deserialize you own data structures conveniently if your system supports C++20. When it is the case, the macro <code>SIMDJSON_SUPPORTS_CONCEPTS</code> will be set to 1 by the simdjson library.</code></p>
<p><code>Consider a custom class <code>Car</code>:</code></p>
<p><code></p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span>Car {</div>
<div class="line">  std::string make;</div>
<div class="line">  std::string model;</div>
<div class="line">  <span class="keywordtype">int</span> year;</div>
<div class="line">  std::vector&lt;float&gt; tire_pressure;</div>
<div class="line">};</div>
</div><!-- fragment --><p></code></p>
<p><code>You may support deserializing directly from a JSON value or document to your own <code>Car</code> instance by defining a single <code>tag_invoke</code> function:</code></p>
<p><code></p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacesimdjson.html">simdjson</a> {</div>
<div class="line"><span class="comment">// This tag_invoke MUST be inside simdjson namespace</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> simdjson_value&gt;</div>
<div class="line"><span class="keyword">auto</span> tag_invoke(deserialize_tag, simdjson_value &amp;val, Car&amp; car) {</div>
<div class="line">  ondemand::object obj;</div>
<div class="line">  <span class="keyword">auto</span> error = val.get_object().get(obj);</div>
<div class="line">  <span class="keywordflow">if</span> (error) {</div>
<div class="line">    <span class="keywordflow">return</span> error;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> ((error = obj[<span class="stringliteral">&quot;make&quot;</span>].get_string(car.make))) {</div>
<div class="line">    <span class="keywordflow">return</span> error;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> ((error = obj[<span class="stringliteral">&quot;model&quot;</span>].get_string(car.model))) {</div>
<div class="line">    <span class="keywordflow">return</span> error;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> ((error = obj[<span class="stringliteral">&quot;year&quot;</span>].get(car.year))) {</div>
<div class="line">    <span class="keywordflow">return</span> error;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> ((error = obj[<span class="stringliteral">&quot;tire_pressure&quot;</span>].get&lt;std::vector&lt;float&gt;&gt;().get(</div>
<div class="line">           car.tire_pressure))) {</div>
<div class="line">    <span class="keywordflow">return</span> error;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9aa4ffc800804829a88c5b52ac3c4c6681">simdjson::SUCCESS</a>;</div>
<div class="line">}</div>
<div class="line">} <span class="comment">// namespace simdjson</span></div>
<div class="ttc" id="anamespacesimdjson_html"><div class="ttname"><a href="namespacesimdjson.html">simdjson</a></div><div class="ttdoc">The top level simdjson namespace, containing everything the library provides.</div><div class="ttdef"><b>Definition</b> <a href="arm64_2base_8h_source.html#l00008">base.h:8</a></div></div>
<div class="ttc" id="anamespacesimdjson_html_a7b735a3a50ba79e3f7f14df5f77d8da9aa4ffc800804829a88c5b52ac3c4c6681"><div class="ttname"><a href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9aa4ffc800804829a88c5b52ac3c4c6681">simdjson::SUCCESS</a></div><div class="ttdeci">@ SUCCESS</div><div class="ttdoc">No error.</div><div class="ttdef"><b>Definition</b> <a href="error_8h_source.html#l00020">error.h:20</a></div></div>
</div><!-- fragment --><p></code></p>
<p><code>Importantly, the <code>tag_invoke</code> function must be inside the <code>simdjson</code> namespace. Let us explain each argument of <code>tag_invoke</code> function.</code></p>
<p><code></p><ul>
<li><code>simdjson::deserialize_tag</code>: it is the tag for Customization Point Object (CPO). You may often ignore this parameter. It is used to indicate that you mean to provide a deserialization function for simdjson.</li>
<li><code>var</code>: It receives automatically a <code>simdjson</code> value type (document, value, document_reference).</li>
<li>The third parameter is an instance of the type that you want to support.</li>
</ul>
<p></code></p>
<p><code>Please see our main documentation (<code>basics.md</code>) under "Use `tag_invoke` for custom types (C++20)" for details about tag_invoke functions.</code></p>
<p><code>Given a stream of JSON documents, you can add them to a data structure such as a <code>std::vector&lt;Car&gt;</code> like so if you support exceptions:</code></p>
<p><code></p><div class="fragment"><div class="line"> ++</div>
<div class="line">  padded_string json =</div>
<div class="line">      R<span class="stringliteral">&quot;( { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018,</span></div>
<div class="line"><span class="stringliteral">       &quot;tire_pressure&quot;: [ 40.1, 39.9 ] }</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012,</span></div>
<div class="line"><span class="stringliteral">       &quot;tire_pressure&quot;: [ 30.1, 31.0 ] }</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999,</span></div>
<div class="line"><span class="stringliteral">       &quot;tire_pressure&quot;: [ 29.8, 30.0 ] }</span></div>
<div class="line"><span class="stringliteral">)&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">  ondemand::parser parser;</span></div>
<div class="line"><span class="stringliteral">  ondemand::document_stream stream;</span></div>
<div class="line"><span class="stringliteral">  [[maybe_unused]] </span><span class="keyword">auto</span> error = parser.iterate_many(json).get(stream);</div>
<div class="line">  std::vector&lt;Car&gt; cars;</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> doc : stream) {</div>
<div class="line">    cars.push_back((Car)doc); <span class="comment">// an exception may be thrown</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p></code></p>
<p><code>Otherwise you may use this longer version for explicit handling of errors:</code></p>
<p><code></p><div class="fragment"><div class="line">++</div>
<div class="line"> std::vector&lt;Car&gt; cars;</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">auto</span> doc : stream) {</div>
<div class="line">   Car c;</div>
<div class="line">   <span class="keywordflow">if</span> ((error = doc.get&lt;Car&gt;().get(c))) {</div>
<div class="line">     std::cerr &lt;&lt; <a class="code hl_function" href="namespacesimdjson.html#a65b00a7a7a9c8fafe9eb3b9b413a36fa">simdjson::error_message</a>(error); &lt;&lt; std::endl;</div>
<div class="line">     <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">   }</div>
<div class="line">   cars.push_back(c);</div>
<div class="line"> }</div>
<div class="ttc" id="anamespacesimdjson_html_a65b00a7a7a9c8fafe9eb3b9b413a36fa"><div class="ttname"><a href="namespacesimdjson.html#a65b00a7a7a9c8fafe9eb3b9b413a36fa">simdjson::error_message</a></div><div class="ttdeci">const char * error_message(error_code error) noexcept</div><div class="ttdoc">It is the convention throughout the code that the macro SIMDJSON_DEVELOPMENT_CHECKS determines whethe...</div><div class="ttdef"><b>Definition</b> <a href="error-inl_8h_source.html#l00025">error-inl.h:25</a></div></div>
</div><!-- fragment --><p> </code></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
