<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: Builder</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logotiny.png"/></td>
  <td id="projectalign">
   <div id="projectname">simdjson<span id="projectnumber">&#160;4.2.1</span>
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doc_2builder.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Builder</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Sometimes you want to generate JSON string outputs efficiently. The simdjson library provides high-performance low-level facilities. When using these low-level functionalities, you are responsible to define the structure of your JSON document. Our more advanced interface automates the process using C++26 static reflection: you get both high speed and high convenience.</p>
<ul>
<li>Builder<ul>
<li>Overview: string_builder</li>
<li>Example: string_builder</li>
<li>C++26 static reflection<ul>
<li>Without `string_buffer` instance</li>
<li>Without `string_buffer` instance but with explicit error handling</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md45"></a>
Overview: string_builder</h1>
<p>The string_builder class is a low-level utility for constructing JSON strings representing documents. It is optimized for performance, potentially leveraging kernel-specific features like SIMD instructions for tasks such as string escaping. This class supports atomic types (e.g., booleans, numbers, strings) but does not handle composed types directly (like arrays or objects). Note that JSON strings are always encoded as UTF-8.</p>
<p>An <code>string_builder</code> is created with an initial buffer capacity (e.g., 1kB). The memory is reallocated when needed. The efficiency of <code>string_builder</code> stems from its internal use of a resizable array or buffer. When you append data, it adds the characters to this buffer, resizing it only when necessary, typically in a way that minimizes reallocations. This approach contrasts with regular string concatenation, where each operation creates a new string, copying all previous content, leading to quadratic time complexity for repeated concatenations.</p>
<p>It has the following methods to add content to the string:</p>
<ul>
<li><code>append(number_type v)</code>: Appends a number (including booleans) to the JSON buffer. Booleans are converted to the strings "false" or "true". Numbers are formatted according to the JSON standard, with floating-point numbers using the shortest representation that accurately reflects the value.</li>
<li><code>append(char c)</code>: Appends a single character to the JSON buffer.</li>
<li><code>append_null()</code>: Appends the string "null" to the JSON buffer.</li>
<li><code>clear()</code>: Clears the contents of the JSON buffer, resetting the position to 0 while retaining the allocated capacity.</li>
<li><code>escape_and_append(std::string_view input)</code>: Appends a string view to the JSON buffer after escaping special characters (e.g., quotes, backslashes) as required by JSON.</li>
<li><code>escape_and_append_with_quotes(std::string_view input)</code> Appends a string view surrounded by double quotes (e.g., "input") to the JSON buffer after escaping special characters. For constant strings, you may also do <code>escape_and_append_with_quotes&lt;"mystring"&gt;()</code>.</li>
<li><code>escape_and_append_with_quotes(char input)</code>: Appends a single character surrounded by double quotes (e.g., "c") to the JSON buffer after escaping it if necessary.</li>
<li><code>append_raw(const char *c)</code>: Appends a null-terminated C string directly to the JSON buffer without escaping.</li>
<li><code>append_raw(std::string_view input)</code>: Appends a string view directly to the JSON buffer without escaping.</li>
<li><code>append_raw(const char *str, size_t len)</code>: Appends a specified number of characters from a C string directly to the JSON</li>
<li><code>append_key_value(key,value)</code>: Appends a key and a value (<code>"json":somevalue</code>)</li>
<li><code>append_key_value&lt;"mykey"&gt;(value)</code>: Appends a key and a value (<code>"json":somevalue</code>), useful when the key is a compile-time constant (C++20).</li>
</ul>
<p>After writing the content, if you have reasons to believe that the content might violate UTF-8 conventions, you can check it as follows:</p>
<ul>
<li><code>validate_unicode()</code>: Checks if the content in the JSON buffer is valid UTF-8. Returns: true if the content is valid UTF-8, false otherwise.</li>
</ul>
<p>You might need to do unicode validation if you have strings in your data structures containing malformed UTF-8. Note that we do not automatically call <code>validate_unicode()</code>.</p>
<p>Once you are satisfied, you can recover the string as follows:</p>
<ul>
<li><code>operator std::string()</code>: Converts the JSON buffer to an std::string. (Might throw if an error occurred.)</li>
<li><code>operator std::string_view()</code>: Converts the JSON buffer to an std::string_view. (Might throw if an error occurred.)</li>
<li><code>view()</code>: Returns a view of the written JSON buffer as a <code>simdjson_result&lt;std::string_view&gt;</code> (C++20).</li>
</ul>
<p>The later method (<code>view()</code>) is recommended. For performance reasons, we expect you to explicitly call <code>validate_unicode()</code> as needed (e.g., prior to calling <code>view()</code>).</p>
<h1><a class="anchor" id="autotoc_md46"></a>
Example: string_builder</h1>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Car {</div>
<div class="line">    std::string make;</div>
<div class="line">    std::string model;</div>
<div class="line">    int64_t year;</div>
<div class="line">    std::vector&lt;double&gt; tire_pressure;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> serialize_car(<span class="keyword">const</span> Car&amp; car, simdjson::builder::string_builder&amp; builder) {</div>
<div class="line">    <span class="comment">// start of JSON</span></div>
<div class="line">    builder.start_object();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;make&quot;</span></div>
<div class="line">    builder.append_key_value(<span class="stringliteral">&quot;make&quot;</span>, car.make);</div>
<div class="line">    builder.append_comma();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;model&quot;</span></div>
<div class="line">    builder.append_key_value(<span class="stringliteral">&quot;model&quot;</span>, car.model);</div>
<div class="line">    builder.append_comma();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;year&quot;</span></div>
<div class="line">    builder.append_key_value(<span class="stringliteral">&quot;year&quot;</span>, car.year);</div>
<div class="line">    builder.append_comma();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;tire_pressure&quot;</span></div>
<div class="line">    builder.escape_and_append_with_quotes(<span class="stringliteral">&quot;tire_pressure&quot;</span>);</div>
<div class="line">    builder.append_colon();</div>
<div class="line">    builder.start_array();</div>
<div class="line">    <span class="comment">// vector tire_pressure</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; car.tire_pressure.size(); ++i) {</div>
<div class="line">        builder.append(car.tire_pressure[i]);</div>
<div class="line">        <span class="keywordflow">if</span> (i &lt; car.tire_pressure.size() - 1) {</div>
<div class="line">            builder.append_comma();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    builder.end_array();</div>
<div class="line">    builder.end_object();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> car_test() {</div>
<div class="line">    simdjson::builder::string_builder sb;</div>
<div class="line">    Car c = {<span class="stringliteral">&quot;Toyota&quot;</span>, <span class="stringliteral">&quot;Corolla&quot;</span>, 2017, {30.0,30.2,30.513,30.79}};</div>
<div class="line">    serialize_car(c, sb);</div>
<div class="line">    std::string_view p{sb};</div>
<div class="line">    <span class="comment">// p holds the JSON:</span></div>
<div class="line">    <span class="comment">// &quot;{\&quot;make\&quot;:\&quot;Toyota\&quot;,\&quot;model\&quot;:\&quot;Corolla\&quot;,\&quot;year\&quot;:2017,\&quot;tire_pressure\&quot;:[30.0,30.2,30.513,30.79]}&quot;</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>string_builder</code> constructor takes an optional parameter which specifies the initial memory allocation in byte. If you know approximately the size of your JSON output, you can pass this value as a parameter (e.g., <code>simdjson::builder::string_builder sb{1233213}</code>).</p>
<p>The <code>string_builder</code> might throw an exception in case of error when you cast it result to <code>std::string_view</code>. If you wish to avoid exceptions, you can use the following programming pattern:</p>
<div class="fragment"><div class="line">std::string_view p;</div>
<div class="line"><span class="keywordflow">if</span>(sb.view().get(p)) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// there was an error</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In all cases, the <code>std::string_view</code> instance depends the corresponding <code>string_builder</code> instance.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
C++20</h2>
<p>If you have C++20, you can simplify the code, as the <code>std::vector&lt;double&gt;</code> is automatically supported. Further, we can pass the keys (which are compile-time constant) as template parameter (for improved performance).</p>
<div class="fragment"><div class="line">Car c = {<span class="stringliteral">&quot;Toyota&quot;</span>, <span class="stringliteral">&quot;Corolla&quot;</span>, 2017, {30.0,30.2,30.513,30.79}};</div>
<div class="line">simdjson::builder::string_builder sb;</div>
<div class="line">sb.start_object();</div>
<div class="line">sb.append_key_value&lt;<span class="stringliteral">&quot;make&quot;</span>&gt;(c.make);</div>
<div class="line">sb.append_comma();</div>
<div class="line">sb.append_key_value&lt;<span class="stringliteral">&quot;model&quot;</span>&gt;(c.model);</div>
<div class="line">sb.append_comma();</div>
<div class="line">sb.append_key_value&lt;<span class="stringliteral">&quot;year&quot;</span>&gt;(c.year);</div>
<div class="line">sb.append_comma();</div>
<div class="line">sb.append_key_value&lt;<span class="stringliteral">&quot;tire_pressure&quot;</span>&gt;(c.tire_pressure);</div>
<div class="line">sb.end_object();</div>
<div class="line">std::string_view p = sb.view();</div>
</div><!-- fragment --><p>With C++20, you can similarly handle standard containers transparently. For example, you can serialize <code>std::map&lt;std::string,T&gt;</code> types.</p>
<div class="fragment"><div class="line">std::map&lt;std::string,double&gt; c = {{<span class="stringliteral">&quot;key1&quot;</span>, 1}, {<span class="stringliteral">&quot;key2&quot;</span>, 1}};</div>
<div class="line">simdjson::builder::string_builder sb;</div>
<div class="line">sb.append(c);</div>
<div class="line">std::string_view p = sb.view();</div>
</div><!-- fragment --><p>You can also serialize <code>std::vector&lt;T&gt;</code> types.</p>
<div class="fragment"><div class="line">std::vector&lt;std::vector&lt;double&gt;&gt; c = {{1.0, 2.0}, {3.0, 4.0}};</div>
<div class="line">simdjson::builder::string_builder sb;</div>
<div class="line">sb.append(c);</div>
<div class="line">std::string_view p = sb.view();</div>
</div><!-- fragment --><p>You can also skip the creation for the <code>string_builder</code> instance in such simple cases.</p>
<div class="fragment"><div class="line">std::vector&lt;std::vector&lt;double&gt;&gt; c = {{1.0, 2.0}, {3.0, 4.0}};</div>
<div class="line">std::string json = simdjson::to_json(c);</div>
</div><!-- fragment --><p>We also have an overload for when you want to reuse the same <code>std::string</code> instance:</p>
<div class="fragment"><div class="line">std::vector&lt;std::vector&lt;double&gt;&gt; c = {{1.0, 2.0}, {3.0, 4.0}};</div>
<div class="line">std::string json;</div>
<div class="line"><span class="keyword">auto</span> error = simdjson::to_json(c, json);</div>
<div class="line"><span class="keywordflow">if</span>(error) { <span class="comment">/* there was an error */</span> }</div>
</div><!-- fragment --><p>We do recommend that you create and reuse the <code>string_builder</code> instance for performance reasons.</p>
<p>You can also add custom serialization functions using a <code>tag_invoke</code> function. For example, the following function will allow you to serialize instances of the type <code>Car</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;simdjson&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Car {</div>
<div class="line">  std::string make;</div>
<div class="line">  std::string model;</div>
<div class="line">  int64_t year;</div>
<div class="line">  std::vector&lt;float&gt; tire_pressure;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacesimdjson.html">simdjson</a> {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> builder_type&gt;</div>
<div class="line"><span class="keywordtype">void</span> tag_invoke(serialize_tag, builder_type &amp;builder, <span class="keyword">const</span> Car&amp; car) {</div>
<div class="line">  builder.start_object();</div>
<div class="line">  builder.append_key_value(<span class="stringliteral">&quot;make&quot;</span>, car.make);</div>
<div class="line">  builder.append_comma();</div>
<div class="line">  builder.append_key_value(<span class="stringliteral">&quot;model&quot;</span>, car.model);</div>
<div class="line">  builder.append_comma();</div>
<div class="line">  builder.append_key_value(<span class="stringliteral">&quot;year&quot;</span>, car.year);</div>
<div class="line">  builder.append_comma();</div>
<div class="line">  builder.append_key_value(<span class="stringliteral">&quot;tire_pressure&quot;</span>, car.tire_pressure);</div>
<div class="line">  builder.end_object();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace simdjson</span></div>
<div class="ttc" id="anamespacesimdjson_html"><div class="ttname"><a href="namespacesimdjson.html">simdjson</a></div><div class="ttdoc">The top level simdjson namespace, containing everything the library provides.</div><div class="ttdef"><b>Definition</b> <a href="arm64_2base_8h_source.html#l00008">base.h:8</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md48"></a>
C++26 static reflection</h1>
<p>Static reflection (or compile-time reflection) in C++26 introduces a powerful compile-time mechanism that allows a program to inspect and manipulate its own structure, such as types, variables, functions, and other program elements, during compilation. Unlike runtime reflection in languages like Java or Python, C++26’s static reflection operates entirely at compile time, aligning with C++’s emphasis on zero-overhead abstractions and high performance. It means that you can delegate much of the work to the library. If you have a compiler with support C++26 static reflection, you can compile your code with the <code>SIMDJSON_STATIC_REFLECTION</code> macro set:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define SIMDJSON_STATIC_REFLECTION 1</span></div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="simdjson_8h.html">simdjson.h</a>&quot;</span></div>
<div class="ttc" id="asimdjson_8h_html"><div class="ttname"><a href="simdjson_8h.html">simdjson.h</a></div></div>
</div><!-- fragment --><p>And then you can append your data structures to a <code>string_builder</code> instance automatically. In most cases, it should work automatically:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Car {</div>
<div class="line">    std::string make;</div>
<div class="line">    std::string model;</div>
<div class="line">    int64_t year;</div>
<div class="line">    std::vector&lt;double&gt; tire_pressure;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> car_test() {</div>
<div class="line">    simdjson::builder::string_builder sb;</div>
<div class="line">    Car c = {<span class="stringliteral">&quot;Toyota&quot;</span>, <span class="stringliteral">&quot;Corolla&quot;</span>, 2017, {30.0,30.2,30.513,30.79}};</div>
<div class="line">    sb &lt;&lt; c;</div>
<div class="line">    std::string_view p{sb};</div>
<div class="line">    <span class="comment">// p holds the JSON:</span></div>
<div class="line">    <span class="comment">// &quot;{\&quot;make\&quot;:\&quot;Toyota\&quot;,\&quot;model\&quot;:\&quot;Corolla\&quot;,\&quot;year\&quot;:2017,\&quot;tire_pressure\&quot;:[30.0,30.2,30.513,30.79]}&quot;</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md49"></a>
Without &lt;tt&gt;string_buffer&lt;/tt&gt; instance</h2>
<p>In some instances, you might want to create a string directly from your own data type. You can create a string directly, without an explicit <code>string_builder</code> instance with the <code>simdjson::to_json</code> template function. (Under the hood a <code>string_builder</code> instance may still be created.)</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Car {</div>
<div class="line">    std::string make;</div>
<div class="line">    std::string model;</div>
<div class="line">    int64_t year;</div>
<div class="line">    std::vector&lt;double&gt; tire_pressure;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">    Car c = {<span class="stringliteral">&quot;Toyota&quot;</span>, <span class="stringliteral">&quot;Corolla&quot;</span>, 2017, {30.0,30.2,30.513,30.79}};</div>
<div class="line">    std::string json = simdjson::to_json(c);</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you know the output size, in bytes, of your JSON string, you may pass it as a second parameter (e.g., <code>simdjson::to_json(c, 31123)</code>).</p>
<p>Sometimes you may want to reuse the same <code>std::string</code> instance. We have an overload for this purpose:</p>
<div class="fragment"><div class="line">Car c = {<span class="stringliteral">&quot;Toyota&quot;</span>, <span class="stringliteral">&quot;Corolla&quot;</span>, 2017, {30.0,30.2,30.513,30.79}};</div>
<div class="line">std::string s;</div>
<div class="line"><span class="keyword">auto</span> error = simdjson::to_json(c, s);</div>
<div class="line"><span class="keywordflow">if</span>(error) { <span class="comment">/* there was an error */</span> }</div>
</div><!-- fragment --><p>You can then also add a third parameter for the expected output size in bytes.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Extracting just some fields</h2>
<p>In some instances, your class might have many fields that you do not want to serialize. You can achieve this result with the <code>simdjson::extract_from</code> template. In the following example, we serialize only the <code>year</code> and <code>price</code> fields on the <code>Car</code> instance. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Car {</div>
<div class="line">    std::string make;</div>
<div class="line">    std::string model;</div>
<div class="line">    <span class="keywordtype">int</span> year;</div>
<div class="line">    <span class="keywordtype">double</span> price;</div>
<div class="line">    <span class="keywordtype">bool</span> electric;</div>
<div class="line">};</div>
<div class="line">Car car{<span class="stringliteral">&quot;Ford&quot;</span>, <span class="stringliteral">&quot;F-150&quot;</span>, 2024, 55000.0, <span class="keyword">false</span>};</div>
<div class="line"><span class="comment">// Extract year and price</span></div>
<div class="line">std::string json_result = simdjson::extract_from&lt;<span class="stringliteral">&quot;year&quot;</span>, <span class="stringliteral">&quot;price&quot;</span>&gt;(car);</div>
<div class="line"><span class="comment">// Alternatively:</span></div>
<div class="line"><span class="comment">// std::string json_result;</span></div>
<div class="line"><span class="comment">// auto error =  extract_from&lt;&quot;year&quot;, &quot;price&quot;&gt;(car).get(json_result);</span></div>
<div class="line"><span class="comment">// if(error) { /* error handling */ }</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md51"></a>
Without &lt;tt&gt;string_buffer&lt;/tt&gt; instance but with explicit error handling</h2>
<p>If prefer a version without exceptions and explicit error handling, you can use the following pattern:</p>
<div class="fragment"><div class="line">std::string json;</div>
<div class="line"><span class="keywordflow">if</span>(simdjson::to_json(c).get(json)) {</div>
<div class="line">  <span class="comment">// there was an error</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// json contain the serialized JSON</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md52"></a>
Customization</h2>
<p>If you want to serialize a value in a custome way, you can do it with a <code>tag_invoke</code> specialization like the following example which will map the year attribute to a string.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;simdjson&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Car {</div>
<div class="line">  std::string make;</div>
<div class="line">  std::string model;</div>
<div class="line">  int64_t year;</div>
<div class="line">  std::vector&lt;float&gt; tire_pressure;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacesimdjson.html">simdjson</a> {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> builder_type&gt;</div>
<div class="line"><span class="keywordtype">void</span> tag_invoke(serialize_tag, builder_type &amp;builder, <span class="keyword">const</span> Car&amp; car) {</div>
<div class="line">  builder.start_object();</div>
<div class="line">  builder.append_key_value(<span class="stringliteral">&quot;make&quot;</span>, car.make);</div>
<div class="line">  builder.append_comma();</div>
<div class="line">  builder.append_key_value(<span class="stringliteral">&quot;model&quot;</span>, car.model);</div>
<div class="line">  builder.append_comma();</div>
<div class="line">  builder.append_key_value(<span class="stringliteral">&quot;year&quot;</span>, std::to_string(car.year));</div>
<div class="line">  builder.append_comma();</div>
<div class="line">  builder.append_key_value(<span class="stringliteral">&quot;tire_pressure&quot;</span>, car.tire_pressure);</div>
<div class="line">  builder.end_object();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace simdjson</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
