<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: The Document-Object-Model (DOM) front-end</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logotiny.png"/></td>
  <td id="projectalign">
   <div id="projectname">simdjson<span id="projectnumber">&#160;4.0.7</span>
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doc_2dom.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The Document-Object-Model (DOM) front-end</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>An overview of what you need to know to use simdjson to parse JSON documents with our DOM API, with examples. <a href="https://github.com/simdjson/simdjson/blob/master/doc/builder.md">Our documentation regarding the generation (serialization) of JSON documents is in a separate document</a>.</p>
<ul>
<li>DOM vs On-Demand</li>
<li>The Basics: Loading and Parsing JSON Documents</li>
<li>Using the Parsed JSON</li>
<li>C++17 Support</li>
<li>C++20 Support</li>
<li>JSON Pointer</li>
<li>JSONPath</li>
<li>Error Handling<ul>
<li>Error Handling Example</li>
<li>Exceptions</li>
</ul>
</li>
<li>Tree Walking and JSON Element Types</li>
<li>Reusing the parser for maximum efficiency</li>
<li>Server Loops: Long-Running Processes and Memory Capacity</li>
<li>Best Use of the DOM API</li>
<li>Padding and Temporary Copies</li>
<li>Performance Tips</li>
</ul>
<h1><a class="anchor" id="autotoc_md50"></a>
DOM vs On-Demand</h1>
<p>The simdjson library offers two distinct approaches on how to access a JSON document. We support a conventional Document-Object-Model (DOM) front-end. In such a scenario, the JSON document is entirely parsed, validated and materialized in memory as the first step. The programmer may then access the parsed data using this in-memory model.</p>
<p>On-Demand is a different model where you parse just what you need, directly into your own data structure. The On-Demand approach, when well tuned, can provide superior performance. <a href="https://github.com/simdjson/simdjson/blob/master/doc/basics.md">We refer you to the On-Demand documentation for further details</a>.</p>
<h1><a class="anchor" id="autotoc_md51"></a>
The Basics: Loading and Parsing JSON Documents using the DOM front-end</h1>
<p>The simdjson library offers a simple DOM tree API, which you can access by creating a <code>dom::parser</code> and calling the <code>load()</code> method:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">dom::parser parser;</div>
<div class="line">dom::element doc = parser.load(filename); <span class="comment">// load and parse a file</span></div>
</div><!-- fragment --><p>Or by creating a padded string (for efficiency reasons, simdjson requires a string with SIMDJSON_PADDING bytes at the end) and calling <code>parse()</code>:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">dom::parser parser;</div>
<div class="line">dom::element doc = parser.parse(<span class="stringliteral">&quot;[1,2,3]&quot;</span>_padded); <span class="comment">// parse a string, the _padded suffix creates a simdjson::padded_string instance</span></div>
</div><!-- fragment --><p>You can copy your data directly on a <code><a class="el" href="structsimdjson_1_1padded__string.html" title="String with extra allocation for ease of use with parser::parse()">simdjson::padded_string</a></code> as follows:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * data = <span class="stringliteral">&quot;my data&quot;</span>; <span class="comment">// 7 bytes</span></div>
<div class="line"><a class="code hl_struct" href="structsimdjson_1_1padded__string.html">simdjson::padded_string</a> my_padded_data(data, 7); <span class="comment">// copies to a padded buffer</span></div>
<div class="ttc" id="astructsimdjson_1_1padded__string_html"><div class="ttname"><a href="structsimdjson_1_1padded__string.html">simdjson::padded_string</a></div><div class="ttdoc">String with extra allocation for ease of use with parser::parse()</div><div class="ttdef"><b>Definition</b> <a href="padded__string_8h_source.html#l00023">padded_string.h:23</a></div></div>
</div><!-- fragment --><p>Or as follows...</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">std::string data = <span class="stringliteral">&quot;my data&quot;</span>;</div>
<div class="line"><a class="code hl_struct" href="structsimdjson_1_1padded__string.html">simdjson::padded_string</a> my_padded_data(data); <span class="comment">// copies to a padded buffer</span></div>
</div><!-- fragment --><p>You can then parse the JSON document from the <code><a class="el" href="structsimdjson_1_1padded__string.html" title="String with extra allocation for ease of use with parser::parse()">simdjson::padded_string</a></code> instance:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsimdjson_1_1dom_1_1parser.html">simdjson::dom::parser</a> parser;</div>
<div class="line"><a class="code hl_class" href="classsimdjson_1_1dom_1_1element.html">simdjson::dom::element</a> doc = parser.<a class="code hl_function" href="classsimdjson_1_1dom_1_1parser.html#a16c7d1e28125ef7d5703244483f70984">parse</a>(my_padded_data);</div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1element_html"><div class="ttname"><a href="classsimdjson_1_1dom_1_1element.html">simdjson::dom::element</a></div><div class="ttdoc">A JSON element.</div><div class="ttdef"><b>Definition</b> <a href="element_8h_source.html#l00033">element.h:33</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html">simdjson::dom::parser</a></div><div class="ttdoc">A persistent document parser.</div><div class="ttdef"><b>Definition</b> <a href="dom_2parser_8h_source.html#l00030">parser.h:30</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_a16c7d1e28125ef7d5703244483f70984"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#a16c7d1e28125ef7d5703244483f70984">simdjson::dom::parser::parse</a></div><div class="ttdeci">simdjson_result&lt; element &gt; parse(const uint8_t *buf, size_t len, bool realloc_if_needed=true) &amp;noexcept</div><div class="ttdoc">Parse a JSON document and return a temporary reference to it.</div><div class="ttdef"><b>Definition</b> <a href="dom_2parser-inl_8h_source.html#l00153">parser-inl.h:153</a></div></div>
</div><!-- fragment --><p>Whenever you pass an <code>std::string</code> reference to <code>parser::parse</code>, the parser will access the bytes beyond the end of the string but before the end of the allocated memory (<code>std::string::capacity()</code>). If you are using a sanitizer that checks for reading uninitialized bytes or <code>std::string</code>'s container-overflow checks, you may encounter sanitizer warnings. You can safely ignore these warnings. Or you can call <code><a class="el" href="namespacesimdjson.html#ac4131fd8cef9c8046d0bc9aee8d44d16" title="Create a padded_string_view from a string.">simdjson::pad</a>(std::string&amp;)</code> to pad the string with <code>SIMDJSON_PADDING</code> spaces: this function returns a <code>simdjson::padding_string_view</code> which can be be passed to the parser's iterator function:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">std::string json = <span class="stringliteral">&quot;[1]&quot;</span>;</div>
<div class="line">dom::element doc = parser.parse(<a class="code hl_function" href="namespacesimdjson.html#ac4131fd8cef9c8046d0bc9aee8d44d16">simdjson::pad</a>(json));</div>
<div class="ttc" id="anamespacesimdjson_html_ac4131fd8cef9c8046d0bc9aee8d44d16"><div class="ttname"><a href="namespacesimdjson.html#ac4131fd8cef9c8046d0bc9aee8d44d16">simdjson::pad</a></div><div class="ttdeci">padded_string_view pad(std::string &amp;s) noexcept</div><div class="ttdoc">Create a padded_string_view from a string.</div><div class="ttdef"><b>Definition</b> <a href="padded__string__view-inl_8h_source.html#l00072">padded_string_view-inl.h:72</a></div></div>
</div><!-- fragment --><p>The parsed document resulting from the <code>parser.load</code> and <code>parser.parse</code> calls depends on the <code>parser</code> instance. Thus the <code>parser</code> instance must remain in scope. Furthermore, you must have at most one parsed document in play per <code>parser</code> instance. You cannot copy a <code>parser</code> instance, you may only move it.</p>
<p>If you need to keep a document around long term, you can keep or move the parser instance. Note that moving a parser instance, or keeping one in a movable data structure like vector or map, can cause any outstanding <code>element</code>, <code>object</code> or <code>array</code> instances to be invalidated. The <code>element</code>, <code>object</code> or <code>array</code> instances are mere thin wrappers akin to an <code>std::vector&lt;int&gt;::iterator</code>: they are invalid when default constructed, they must be tied to a valid document instance. If you need to store a parser in a movable data structure, you should use a <code>std::unique_ptr</code> to avoid this invalidation(e.g., <code>std::unique_ptr&lt;dom::parser&gt; parser(new dom::parser{})</code>).</p>
<p>During the<code>load</code> or <code>parse</code> calls, neither the input file nor the input string are ever modified. After calling <code>load</code> or <code>parse</code>, the source (either a file or a string) can be safely discarded. All of the JSON data is stored in the <code>parser</code> instance. The parsed document is also immutable in simdjson: you do not modify it by accessing it.</p>
<p>For best performance, a <code>parser</code> instance should be reused over several files: otherwise you will needlessly reallocate memory, an expensive process. It is also possible to avoid entirely memory allocations during parsing when using simdjson. <a class="el" href="md_doc_2performance.html">See our performance notes for details</a>.</p>
<p>If you need a lower-level interface, you may call the function <code>parser.parse(const char * p, size_t l)</code> on a pointer <code>p</code> while specifying the length of your input <code>l</code> in bytes.</p>
<p><em>Windows-specific</em>: Windows users who need to read files with non-ANSI characters in the name should set their code page to UTF-8 (65001). This should be the default with Windows 11 and better. Further, they may use the AreFileApisANSI function to determine whether the filename is interpreted using the ANSI or the system default OEM codepage, and they may call SetFileApisToOEM accordingly.</p>
<h1><a class="anchor" id="autotoc_md52"></a>
Using the Parsed JSON</h1>
<p>Once you have an element, you can navigate it with idiomatic C++ iterators, operators and casts.</p>
<ul>
<li><b>Extracting Values (with exceptions):</b> You can cast a JSON element to a native type: <code>double(element)</code> or <code>double x = json_element</code>. This works for double, uint64_t, int64_t, bool, dom::object and dom::array. An exception (<code><a class="el" href="structsimdjson_1_1simdjson__error.html" title="Exception thrown when an exception-supporting simdjson method is called.">simdjson::simdjson_error</a></code>) is thrown if the cast is not possible.</li>
<li><b>Extracting Values (without exceptions):</b> You can use a variant usage of <code>get()</code> with error codes to avoid exceptions. You first declare the variable of the appropriate type (<code>double</code>, <code>uint64_t</code>, <code>int64_t</code>, <code>bool</code>, <code>std::string_view</code>, <code>dom::object</code> and <code>dom::array</code>) and pass it by reference to <code>get()</code> which gives you back an error code: e.g., <div class="fragment"><div class="line">++</div>
<div class="line"> <a class="code hl_enumeration" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">simdjson::error_code</a> error;</div>
<div class="line"> <a class="code hl_struct" href="structsimdjson_1_1padded__string.html">simdjson::padded_string</a> numberstring = <span class="stringliteral">&quot;1.2&quot;</span>_padded; <span class="comment">// our JSON input (&quot;1.2&quot;)</span></div>
<div class="line"> <a class="code hl_class" href="classsimdjson_1_1dom_1_1parser.html">simdjson::dom::parser</a> parser;</div>
<div class="line"> <span class="keywordtype">double</span> value; <span class="comment">// variable where we store the value to be parsed</span></div>
<div class="line"> error = parser.<a class="code hl_function" href="classsimdjson_1_1dom_1_1parser.html#a16c7d1e28125ef7d5703244483f70984">parse</a>(numberstring).get(value);</div>
<div class="line"> <span class="keywordflow">if</span> (error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; <span class="keywordflow">return</span> EXIT_FAILURE; }</div>
<div class="line"> std::cout &lt;&lt; <span class="stringliteral">&quot;I parsed &quot;</span> &lt;&lt; value &lt;&lt; <span class="stringliteral">&quot; from &quot;</span> &lt;&lt; numberstring.<a class="code hl_function" href="structsimdjson_1_1padded__string.html#aadd3bb268cbba43012c5d17a8c1ab7ef">data</a>() &lt;&lt; std::endl;</div>
<div class="ttc" id="anamespacesimdjson_html_a7b735a3a50ba79e3f7f14df5f77d8da9"><div class="ttname"><a href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">simdjson::error_code</a></div><div class="ttdeci">error_code</div><div class="ttdoc">All possible errors returned by simdjson.</div><div class="ttdef"><b>Definition</b> <a href="error_8h_source.html#l00019">error.h:19</a></div></div>
<div class="ttc" id="astructsimdjson_1_1padded__string_html_aadd3bb268cbba43012c5d17a8c1ab7ef"><div class="ttname"><a href="structsimdjson_1_1padded__string.html#aadd3bb268cbba43012c5d17a8c1ab7ef">simdjson::padded_string::data</a></div><div class="ttdeci">const char * data() const noexcept</div><div class="ttdoc">The string data.</div><div class="ttdef"><b>Definition</b> <a href="padded__string-inl_8h_source.html#l00124">padded_string-inl.h:124</a></div></div>
</div><!-- fragment --> The strings contain unescaped valid UTF-8 strings: no unmatched surrogate is allowed. Internally, numbers are stored as either 64-bit integers or 64-bit floating-point numbers. Thus it is possible to get the full 64-bit integer range (either signed or unsigned). By default, the string <code>-0</code> is parsed as the integer 0 as in Python or C++. If you set the macro <code>SIMDJSON_MINUS_ZERO_AS_FLOAT</code> to <code>1</code> when building simdjson, you can get that <code>-0</code> is mapped to <code>-0.0</code> as in JavaScript. You can get the desired effect by building simdjson with cmake setting the <code>SIMDJSON_MINUS_ZERO_AS_FLOAT</code> to on: <code>cmake -B build -D SIMDJSON_MINUS_ZERO_AS_FLOAT=ON</code>.</li>
<li><b>Field Access:</b> To get the value of the "foo" field in an object, use <code>object["foo"]</code>.</li>
<li><b>Array Iteration:</b> To iterate through an array, use <code>for (auto value : array) { ... }</code>. If you know the type of the value, you can cast it right there, too! <code>for (double value : array) { ... }</code></li>
<li><b>Object Iteration:</b> You can iterate through an object's fields, too: <code>for (auto [key, value] : object)</code></li>
<li><b>Array Index:</b> To get at an array value by index, use the at() method: <code>array.at(0)</code> gets the first element. The at() method has linear-time complexity so it should not be used to iterate over the values of an array. <blockquote class="doxtable">
<p>&zwj;Note that array[0] does not compile, because implementing [] gives the impression indexing is a O(1) operation, which it is not presently in simdjson. Instead, you should iterate over the elements using a for-loop, as in our examples. </p>
</blockquote>
* <b>Array and Object size</b> Given an array or an object, you can get its size (number of elements or keys) with the <code>size()</code> method.</li>
<li><b>Checking an Element Type:</b> You can check an element's type with <code>element.type()</code>. It returns an <code>element_type</code> with values such as <code><a class="el" href="namespacesimdjson_1_1dom.html#a6e1dee3a823ecfee91086d3478bbab3aacb4fb1757fb37c43cded35d3eb857c43" title="dom::array">simdjson::dom::element_type::ARRAY</a></code>, <code><a class="el" href="namespacesimdjson_1_1dom.html#a6e1dee3a823ecfee91086d3478bbab3aa8eee8e217391199668cbac89472ace53" title="dom::object">simdjson::dom::element_type::OBJECT</a></code>, <code><a class="el" href="namespacesimdjson_1_1dom.html#a6e1dee3a823ecfee91086d3478bbab3aa4e866b275c85fbb439f6484251cfb31c" title="int64_t">simdjson::dom::element_type::INT64</a></code>, <code><a class="el" href="namespacesimdjson_1_1dom.html#a6e1dee3a823ecfee91086d3478bbab3aa6de7acf711860176ba606e9aa2b85d5f" title="uint64_t: any integer that fits in uint64_t but not int64_t">simdjson::dom::element_type::UINT64</a></code>,<code><a class="el" href="namespacesimdjson_1_1dom.html#a6e1dee3a823ecfee91086d3478bbab3aafd3e4ece78a7d422280d5ed379482229" title="double: Any number with a &quot;.&quot; or &quot;e&quot; that fits in double.">simdjson::dom::element_type::DOUBLE</a></code>, <code><a class="el" href="namespacesimdjson_1_1dom.html#a6e1dee3a823ecfee91086d3478bbab3aa63b588d5559f64f89a416e656880b949" title="std::string_view">simdjson::dom::element_type::STRING</a></code>, <code><a class="el" href="namespacesimdjson_1_1dom.html#a6e1dee3a823ecfee91086d3478bbab3aaa97b2c144243b2b9d2c593ec268b62f5" title="bool">simdjson::dom::element_type::BOOL</a></code> or, <code><a class="el" href="namespacesimdjson_1_1dom.html#a6e1dee3a823ecfee91086d3478bbab3aaa9f0aff2067f91437e50e4872b229e6a" title="null">simdjson::dom::element_type::NULL_VALUE</a></code>.</li>
<li><b>Output to streams and strings:</b> Given a document or an element (or node) out of a JSON document, you can output a minified string version using the C++ stream idiom (<code>out &lt;&lt; element</code>). You can also request the construction of a minified string version (<code>simdjson::minify(element)</code>) or a prettified string version (<code>simdjson::prettify(element)</code>). Numbers are serialized as 64-bit floating-point numbers (<code>double</code>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md53"></a>
Examples</h2>
<p>The following code illustrates all of the above:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> cars_json = R<span class="stringliteral">&quot;( [</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</span></div>
<div class="line"><span class="stringliteral">] )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral"></span><span class="comment">// Iterating through an array of objects</span></div>
<div class="line"><span class="keywordflow">for</span> (dom::object car : parser.parse(cars_json)) {</div>
<div class="line">  <span class="comment">// Accessing a field by name</span></div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Make/Model: &quot;</span> &lt;&lt; car[<span class="stringliteral">&quot;make&quot;</span>] &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; car[<span class="stringliteral">&quot;model&quot;</span>] &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Casting a JSON element to an integer</span></div>
<div class="line">  uint64_t year = car[<span class="stringliteral">&quot;year&quot;</span>];</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;- This car is &quot;</span> &lt;&lt; 2020 - year &lt;&lt; <span class="stringliteral">&quot;years old.&quot;</span> &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Iterating through an array of floats</span></div>
<div class="line">  <span class="keywordtype">double</span> total_tire_pressure = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">double</span> tire_pressure : car[<span class="stringliteral">&quot;tire_pressure&quot;</span>]) {</div>
<div class="line">    total_tire_pressure += tire_pressure;</div>
<div class="line">  }</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;- Average tire pressure: &quot;</span> &lt;&lt; (total_tire_pressure / 4) &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Writing out all the information about the car</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> field : car) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;- &quot;</span> &lt;&lt; field.key &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; field.value &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here is a different example illustrating the same ideas:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> abstract_json = R<span class="stringliteral">&quot;( [</span></div>
<div class="line"><span class="stringliteral">    {  &quot;12345&quot; : {&quot;a&quot;:12.34, &quot;b&quot;:56.78, &quot;c&quot;: 9998877}   },</span></div>
<div class="line"><span class="stringliteral">    {  &quot;12545&quot; : {&quot;a&quot;:11.44, &quot;b&quot;:12.78, &quot;c&quot;: 11111111}  }</span></div>
<div class="line"><span class="stringliteral">  ] )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral"></span><span class="comment">// Parse and iterate through an array of objects</span></div>
<div class="line"><span class="keywordflow">for</span> (dom::object obj : parser.parse(abstract_json)) {</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> key_value : obj) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;key: &quot;</span> &lt;&lt; key_value.key &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;</div>
<div class="line">      dom::object innerobj = key_value.value;</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;a: &quot;</span> &lt;&lt; double(innerobj[<span class="stringliteral">&quot;a&quot;</span>]) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;b: &quot;</span> &lt;&lt; double(innerobj[<span class="stringliteral">&quot;b&quot;</span>]) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;c: &quot;</span> &lt;&lt; int64_t(innerobj[<span class="stringliteral">&quot;c&quot;</span>]) &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And another one:</p>
<div class="fragment"><div class="line">++</div>
<div class="line"> <span class="keyword">auto</span> abstract_json = R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">   {  &quot;str&quot; : { &quot;123&quot; : {&quot;abc&quot; : 3.14 } } } )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral"> dom::parser parser;</span></div>
<div class="line"><span class="stringliteral"> </span><span class="keywordtype">double</span> v = parser.parse(abstract_json)[<span class="stringliteral">&quot;str&quot;</span>][<span class="stringliteral">&quot;123&quot;</span>][<span class="stringliteral">&quot;abc&quot;</span>];</div>
<div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;number: &quot;</span> &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md54"></a>
C++17 Support</h1>
<p>While the simdjson library can be used in any project using C++ 11 and above, field iteration has special support C++ 17's destructuring syntax. For example:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">padded_string json = R<span class="stringliteral">&quot;(  { &quot;foo&quot;: 1, &quot;bar&quot;: 2 }  )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral">dom::object object; </span><span class="comment">// invalid until the get() succeeds</span></div>
<div class="line"><span class="keyword">auto</span> error = parser.parse(json).get(<span class="keywordtype">object</span>);</div>
<div class="line"><span class="keywordflow">if</span> (error) { cerr &lt;&lt; error &lt;&lt; endl; <span class="keywordflow">return</span>; }</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> [key, value] : object) {</div>
<div class="line">  cout &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; value &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For comparison, here is the C++ 11 version of the same code:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// C++ 11 version for comparison</span></div>
<div class="line">padded_string json = R<span class="stringliteral">&quot;(  { &quot;foo&quot;: 1, &quot;bar&quot;: 2 }  )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral">dom::object object; </span><span class="comment">// invalid until the get() succeeds</span></div>
<div class="line"><span class="keyword">auto</span> error = parser.parse(json).get(<span class="keywordtype">object</span>);</div>
<div class="line"><span class="keywordflow">if</span> (error) { cerr &lt;&lt; error &lt;&lt; endl; <span class="keywordflow">return</span>; }</div>
<div class="line"><span class="keywordflow">for</span> (dom::key_value_pair field : object) {</div>
<div class="line">  cout &lt;&lt; field.key &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; field.value &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md55"></a>
C++20 Support</h1>
<p>simdjson library also supports some C++20 feature including <code>std::ranges</code>:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> cars_json = R<span class="stringliteral">&quot;( [</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</span></div>
<div class="line"><span class="stringliteral">] )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral"></span><span class="keyword">auto</span> justmodel = [](<span class="keyword">auto</span> car) { <span class="keywordflow">return</span> car[<span class="stringliteral">&quot;model&quot;</span>]; };</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> car : parser.parse(cars_json).get_array() | std::views::transform(justmodel)) {</div>
<div class="line">  std::cout &lt;&lt; car &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md56"></a>
JSON Pointer</h1>
<p>The simdjson library also supports <a href="https://tools.ietf.org/html/rfc6901">JSON pointer</a> through the <code>at_pointer()</code> method, letting you reach further down into the document in a single call:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> cars_json = R<span class="stringliteral">&quot;( [</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</span></div>
<div class="line"><span class="stringliteral">] )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral">dom::element cars = parser.parse(cars_json);</span></div>
<div class="line"><span class="stringliteral">cout &lt;&lt; cars.at_pointer(</span><span class="stringliteral">&quot;/0/tire_pressure/1&quot;</span>) &lt;&lt; endl; <span class="comment">// Prints 39.9</span></div>
</div><!-- fragment --><p>A JSON Pointer expression is a sequence of segments each starting with the '/' character. Within arrays, an integer index allows you to select the indexed node. Within objects, the string value of the key allows you to select the value. If your keys contain the characters '/' or '~', they must be escaped as '~1' and '~0' respectively. An empty JSON Pointer expression refers to the whole document.</p>
<p>We also extend the JSON Pointer support to include <em>relative</em> paths. You can apply a JSON Pointer expression to any node and the path gets interpreted relatively, as if the current node were a whole JSON document.</p>
<p>Consider the following example:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> cars_json = R<span class="stringliteral">&quot;( [</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</span></div>
<div class="line"><span class="stringliteral">] )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral">dom::element cars = parser.parse(cars_json);</span></div>
<div class="line"><span class="stringliteral">cout &lt;&lt; cars.at_pointer(</span><span class="stringliteral">&quot;/0/tire_pressure/1&quot;</span>) &lt;&lt; endl; <span class="comment">// Prints 39.9</span></div>
<div class="line"><span class="keywordflow">for</span> (dom::element car_element : cars) {</div>
<div class="line">    dom::object car; <span class="comment">// invalid until the get() succeeds</span></div>
<div class="line">    <a class="code hl_enumeration" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">simdjson::error_code</a> error;</div>
<div class="line">    <span class="keywordflow">if</span> ((error = car_element.get(car))) { std::cerr &lt;&lt; error &lt;&lt; std::endl; <span class="keywordflow">return</span>; }</div>
<div class="line">    <span class="keywordtype">double</span> x = car.at_pointer(<span class="stringliteral">&quot;/tire_pressure/1&quot;</span>);</div>
<div class="line">    cout &lt;&lt; x &lt;&lt; endl; <span class="comment">// Prints 39.9, 31 and 30</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md57"></a>
JSONPath</h1>
<p>The simdjson library supports a subset of <a href="https://www.rfc-editor.org/rfc/rfc9535">JSONPath</a> (RFC 9535) through the <code>at_path()</code> method, allowing you to reach further into the document in a single call. The subset of JSONPath that is implemented is the subset that is trivially convertible into the JSON Pointer format, using <code>.</code> to access a field and <code>[]</code> to access a specific index.</p>
<p>Consider the following example:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> cars_json = R<span class="stringliteral">&quot;( [</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</span></div>
<div class="line"><span class="stringliteral">] )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral">dom::element doc;</span></div>
<div class="line"><span class="stringliteral"></span><span class="keyword">auto</span> error = parser.parse(cars_json).get(doc);</div>
<div class="line"><span class="keywordflow">if</span>(error) { <span class="comment">/*won&#39;t happen*/</span> }</div>
<div class="line"><span class="keywordtype">double</span> p;</div>
<div class="line">error = doc.at_path(<span class="stringliteral">&quot;[0].tire_pressure[1]&quot;</span>).get(p);</div>
<div class="line"><span class="keywordflow">if</span>(error) { <span class="comment">/*won&#39;t happen*/</span> }</div>
<div class="line">cout &lt;&lt; p &lt;&lt; endl; <span class="comment">// Prints 39.9</span></div>
</div><!-- fragment --><p>We also support the <code>$</code> prefix. When you start a JSONPath expression with $, you are indicating that the path starts from the root of the JSON document. E.g.,</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> json = R<span class="stringliteral">&quot;( { &quot;c&quot; :{ &quot;foo&quot;: { &quot;a&quot;: [ 10, 20, 30 ] }}, &quot;d&quot;: { &quot;foo2&quot;: { &quot;a&quot;: [ 10, 20, 30 ] }} , &quot;e&quot;: 120 })&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral">dom::element doc;</span></div>
<div class="line"><span class="stringliteral"></span><span class="keyword">auto</span> error = parser.parse(json).get(doc);</div>
<div class="line"><span class="keywordflow">if</span>(error) { <span class="comment">/*won&#39;t happen*/</span> }</div>
<div class="line">dom::object obj;</div>
<div class="line">error = doc.get_object().get(obj);</div>
<div class="line"><span class="keywordflow">if</span>(error) { <span class="comment">/*won&#39;t happen*/</span> }</div>
<div class="line">int64_t x;</div>
<div class="line">error = obj.at_path(<span class="stringliteral">&quot;$[3].foo.a[1]&quot;</span>).get(x);</div>
<div class="line"><span class="keywordflow">if</span>(error) { <span class="comment">/*won&#39;t happen*/</span> }</div>
<div class="line"><span class="keywordflow">if</span>(x != 20) { <span class="comment">/*won&#39;t happen*/</span> }</div>
<div class="line">x = obj.at_path(<span class="stringliteral">&quot;$.d.foo2.a.2&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(error) { <span class="comment">/*won&#39;t happen*/</span> }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md58"></a>
Using &lt;tt&gt;at_path_with_wildcard&lt;/tt&gt; for JSONPath Queries</h1>
<p>The <code>at_path_with_wildcard</code> function in simdjson extends the JSONPath querying capabilities by supporting wildcard expressions (<code>*</code>) in JSON paths. This allows users to retrieve multiple elements from a JSON document in a single query. For example, you can use <code>$.address.*</code> to fetch all fields within the <code>address</code> object or <code>$.phoneNumbers[*].numbers[*]</code> to retrieve all phone numbers across multiple objects in an array.</p>
<p>The <code>*</code> wildcard matches all elements at a specific level. For instance, <code>$.address.*</code> retrieves all key-value pairs in the <code>address</code> object, while <code>$.*.streetAddress</code> fetches all <code>streetAddress</code> fields across objects at the root level. You can combine wildcards with array indexing. For example, <code>$.phoneNumbers[*].numbers[1]</code> retrieves the second number from each <code>numbers</code> array in the <code>phoneNumbers</code> array. If no elements match the wildcard query, the function returns an empty result. For instance, querying <code>$.empty_object.*</code> or <code>$.empty_array.*</code> will yield an empty set.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
Example Usage</h2>
<p>Here is an example demonstrating the use of <code>at_path_with_wildcard</code>:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structsimdjson_1_1padded__string.html">simdjson::padded_string</a> json_string = R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">{</span></div>
<div class="line"><span class="stringliteral">  &quot;firstName&quot;: &quot;John&quot;,</span></div>
<div class="line"><span class="stringliteral">  &quot;lastName&quot;: &quot;doe&quot;,</span></div>
<div class="line"><span class="stringliteral">  &quot;age&quot;: 26,</span></div>
<div class="line"><span class="stringliteral">  &quot;address&quot;: {</span></div>
<div class="line"><span class="stringliteral">    &quot;streetAddress&quot;: &quot;naist street&quot;,</span></div>
<div class="line"><span class="stringliteral">    &quot;city&quot;: &quot;Nara&quot;,</span></div>
<div class="line"><span class="stringliteral">    &quot;postalCode&quot;: &quot;630-0192&quot;</span></div>
<div class="line"><span class="stringliteral">  },</span></div>
<div class="line"><span class="stringliteral">  &quot;phoneNumbers&quot;: [</span></div>
<div class="line"><span class="stringliteral">    {</span></div>
<div class="line"><span class="stringliteral">      &quot;type&quot;: &quot;iPhone&quot;,</span></div>
<div class="line"><span class="stringliteral">      &quot;numbers&quot;: [&quot;0123-4567-8888&quot;, &quot;0123-4567-8788&quot;]</span></div>
<div class="line"><span class="stringliteral">    },</span></div>
<div class="line"><span class="stringliteral">    {</span></div>
<div class="line"><span class="stringliteral">      &quot;type&quot;: &quot;home&quot;,</span></div>
<div class="line"><span class="stringliteral">      &quot;numbers&quot;: [&quot;0123-4567-8910&quot;]</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">  ]</span></div>
<div class="line"><span class="stringliteral">})&quot;_padded;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral">dom::element parsed_json = parser.<a class="code hl_function" href="classsimdjson_1_1dom_1_1parser.html#a16c7d1e28125ef7d5703244483f70984">parse</a>(json_string);</span></div>
<div class="line"><span class="stringliteral">std::vector&lt;dom::element&gt; values;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral"></span><span class="comment">// Fetch all fields in the address object</span></div>
<div class="line"><span class="keyword">auto</span> error = parsed_json.at_path_with_wildcard(<span class="stringliteral">&quot;$.address.*&quot;</span>).get(values);</div>
<div class="line"><span class="keywordflow">if</span>(error) {</div>
<div class="line">  <span class="comment">// do something</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;value : values) {</div>
<div class="line">  std::string_view field;</div>
<div class="line">  error = value.get(field);</div>
<div class="line">  <span class="keywordflow">if</span>(error) {</div>
<div class="line">    <span class="comment">// do something</span></div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; field &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch all phone numbers</span></div>
<div class="line">error = parsed_json.at_path_with_wildcard(<span class="stringliteral">&quot;$.phoneNumbers[*].numbers[*]&quot;</span>).get(values);</div>
<div class="line"><span class="keywordflow">if</span>(error) {</div>
<div class="line">  <span class="comment">// do something</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;value : values) {</div>
<div class="line">  std::string_view <a class="code hl_enumvalue" href="namespacesimdjson_1_1_s_i_m_d_j_s_o_n___i_m_p_l_e_m_e_n_t_a_t_i_o_n_1_1ondemand.html#ac915f0c06e5ab0363e09593bba651330ab1bc248a7ff2b2e95569f56de68615df">number</a>;</div>
<div class="line">  error = value.get(number);</div>
<div class="line">  <span class="keywordflow">if</span>(error) {</div>
<div class="line">    <span class="comment">// do something</span></div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <a class="code hl_enumvalue" href="namespacesimdjson_1_1_s_i_m_d_j_s_o_n___i_m_p_l_e_m_e_n_t_a_t_i_o_n_1_1ondemand.html#ac915f0c06e5ab0363e09593bba651330ab1bc248a7ff2b2e95569f56de68615df">number</a> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacesimdjson_1_1_s_i_m_d_j_s_o_n___i_m_p_l_e_m_e_n_t_a_t_i_o_n_1_1ondemand_html_ac915f0c06e5ab0363e09593bba651330ab1bc248a7ff2b2e95569f56de68615df"><div class="ttname"><a href="namespacesimdjson_1_1_s_i_m_d_j_s_o_n___i_m_p_l_e_m_e_n_t_a_t_i_o_n_1_1ondemand.html#ac915f0c06e5ab0363e09593bba651330ab1bc248a7ff2b2e95569f56de68615df">simdjson::SIMDJSON_IMPLEMENTATION::ondemand::json_type::number</a></div><div class="ttdeci">@ number</div><div class="ttdoc">A JSON number ( 1 or -2.3 or 4.5e6 ...)</div></div>
</div><!-- fragment --><p>This function is particularly useful for extracting data from complex JSON structures with nested arrays and objects. By leveraging wildcards, you can simplify your queries and reduce the need for multiple iterations.</p>
<h1><a class="anchor" id="autotoc_md60"></a>
Error Handling</h1>
<p>All simdjson APIs that can fail return <code>simdjson_result&lt;T&gt;</code>, which is a &lt;value, error_code&gt; pair. You can retrieve the value with .get(), like so:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">dom::element doc;</div>
<div class="line"><span class="keyword">auto</span> error = parser.parse(json).get(doc);</div>
<div class="line"><span class="keywordflow">if</span> (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
</div><!-- fragment --><p>When there is no error, the error code <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9aa4ffc800804829a88c5b52ac3c4c6681" title="No error.">simdjson::SUCCESS</a> is returned: it evaluates as false as a Boolean. We have several error codes to indicate errors, they all evaluate to true as a Boolean: your software should not generally not depend on exact error codes. We may change the error codes in future releases and the exact error codes could vary depending on your system.</p>
<p>When you use the code without exceptions, it is your responsibility to check for error before using the result: if there is an error, the result value will not be valid and using it will caused undefined behavior.</p>
<p>We can write a "quick start" example where we attempt to parse the following JSON file and access some data, without triggering exceptions: </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;id&quot;: 505874924095815700</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      &quot;id&quot;: 505874922023837700</div>
<div class="line">    }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: {</div>
<div class="line">    &quot;count&quot;: 100</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our program loads the file, selects value corresponding to key "search_metadata" which expected to be an object, and then it selects the key "count" within that object.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="simdjson_8h.html">simdjson.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <a class="code hl_class" href="classsimdjson_1_1dom_1_1parser.html">simdjson::dom::parser</a> parser;</div>
<div class="line">  <a class="code hl_class" href="classsimdjson_1_1dom_1_1element.html">simdjson::dom::element</a> tweets; <span class="comment">// invalid until the get() succeeds</span></div>
<div class="line">  <span class="keyword">auto</span> error = parser.<a class="code hl_function" href="classsimdjson_1_1dom_1_1parser.html#ac408e4da66b0ac7cf9734aa4973e0093">load</a>(<span class="stringliteral">&quot;twitter.json&quot;</span>).get(tweets);</div>
<div class="line">  <span class="keywordflow">if</span> (error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; <span class="keywordflow">return</span> EXIT_FAILURE; }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classsimdjson_1_1dom_1_1element.html">simdjson::dom::element</a> res; <span class="comment">// invalid until the get() succeeds</span></div>
<div class="line">  <span class="keywordflow">if</span> ((error = tweets[<span class="stringliteral">&quot;search_metadata&quot;</span>][<span class="stringliteral">&quot;count&quot;</span>].get(res))) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;could not access keys&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; res &lt;&lt; <span class="stringliteral">&quot; results.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_ac408e4da66b0ac7cf9734aa4973e0093"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#ac408e4da66b0ac7cf9734aa4973e0093">simdjson::dom::parser::load</a></div><div class="ttdeci">simdjson_result&lt; element &gt; load(std::string_view path) &amp;noexcept</div><div class="ttdoc">Load a JSON document from a file and return a reference to it.</div><div class="ttdef"><b>Definition</b> <a href="dom_2parser-inl_8h_source.html#l00094">parser-inl.h:94</a></div></div>
<div class="ttc" id="asimdjson_8h_html"><div class="ttname"><a href="simdjson_8h.html">simdjson.h</a></div></div>
</div><!-- fragment --><p>The following is a similar example where one wants to get the id of the first tweet without triggering exceptions. To do this, we use <code>["statuses"].at(0)["id"]</code>. We break that expression down:</p>
<ul>
<li>Get the list of tweets (the <code>"statuses"</code> key of the document) using <code>["statuses"]</code>). The result is expected to be an array.</li>
<li>Get the first tweet using <code>.at(0)</code>. The result is expected to be an object.</li>
<li>Get the id of the tweet using ["id"]. We expect the value to be a non-negative integer.</li>
</ul>
<p>Observe how we use the <code>at</code> method when querying an index into an array, and not the bracket operator.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="simdjson_8h.html">simdjson.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <a class="code hl_class" href="classsimdjson_1_1dom_1_1parser.html">simdjson::dom::parser</a> parser;</div>
<div class="line">  <a class="code hl_class" href="classsimdjson_1_1dom_1_1element.html">simdjson::dom::element</a> tweets; <span class="comment">// invalid until the get() succeeds</span></div>
<div class="line">  <span class="keyword">auto</span> error = parser.<a class="code hl_function" href="classsimdjson_1_1dom_1_1parser.html#ac408e4da66b0ac7cf9734aa4973e0093">load</a>(<span class="stringliteral">&quot;twitter.json&quot;</span>).get(tweets);</div>
<div class="line">  <span class="keywordflow">if</span> (error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; <span class="keywordflow">return</span> EXIT_FAILURE; }</div>
<div class="line">  uint64_t identifier;</div>
<div class="line">  error = tweets[<span class="stringliteral">&quot;statuses&quot;</span>].<a class="code hl_function" href="classsimdjson_1_1dom_1_1element.html#aa8b5798004a859bf922778226b8c1cce">at</a>(0)[<span class="stringliteral">&quot;id&quot;</span>].get(identifier);</div>
<div class="line">  <span class="keywordflow">if</span> (error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; <span class="keywordflow">return</span> EXIT_FAILURE; }</div>
<div class="line">  std::cout &lt;&lt; identifier &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1element_html_aa8b5798004a859bf922778226b8c1cce"><div class="ttname"><a href="classsimdjson_1_1dom_1_1element.html#aa8b5798004a859bf922778226b8c1cce">simdjson::dom::element::at</a></div><div class="ttdeci">simdjson_result&lt; element &gt; at(const std::string_view json_pointer) const noexcept</div><div class="ttdoc">Version 0.4 of simdjson used an incorrect interpretation of the JSON Pointer standard and allowed the...</div><div class="ttdef"><b>Definition</b> <a href="element-inl_8h_source.html#l00448">element-inl.h:448</a></div></div>
</div><!-- fragment --><p>The <code>at()</code> method has linear-time complexity: it should not be used to iterate over the content of an array.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
Error Handling Example</h2>
<p>This is how the example in "Using the Parsed JSON" could be written using only error code checking:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> cars_json = R<span class="stringliteral">&quot;( [</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</span></div>
<div class="line"><span class="stringliteral">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</span></div>
<div class="line"><span class="stringliteral">] )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral">dom::array cars; </span><span class="comment">// invalid until the get() succeeds</span></div>
<div class="line"><span class="keyword">auto</span> error = parser.parse(cars_json).get(cars);</div>
<div class="line"><span class="keywordflow">if</span> (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterating through an array of objects</span></div>
<div class="line"><span class="keywordflow">for</span> (dom::element car_element : cars) {</div>
<div class="line">    dom::object car;</div>
<div class="line">    <span class="keywordflow">if</span> ((error = car_element.get(car))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessing a field by name</span></div>
<div class="line">    std::string_view make, model;</div>
<div class="line">    <span class="keywordflow">if</span> ((error = car[<span class="stringliteral">&quot;make&quot;</span>].get(make))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">    <span class="keywordflow">if</span> ((error = car[<span class="stringliteral">&quot;model&quot;</span>].get(model))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Make/Model: &quot;</span> &lt;&lt; make &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; model &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Casting a JSON element to an integer</span></div>
<div class="line">    uint64_t year;</div>
<div class="line">    <span class="keywordflow">if</span> ((error = car[<span class="stringliteral">&quot;year&quot;</span>].get(year))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;- This car is &quot;</span> &lt;&lt; 2020 - year &lt;&lt; <span class="stringliteral">&quot;years old.&quot;</span> &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Iterating through an array of floats</span></div>
<div class="line">    <span class="keywordtype">double</span> total_tire_pressure = 0;</div>
<div class="line">    dom::array tire_pressure_array;</div>
<div class="line">    <span class="keywordflow">if</span> ((error = car[<span class="stringliteral">&quot;tire_pressure&quot;</span>].get(tire_pressure_array))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">    <span class="keywordflow">for</span> (dom::element tire_pressure_element : tire_pressure_array) {</div>
<div class="line">        <span class="keywordtype">double</span> tire_pressure;</div>
<div class="line">        <span class="keywordflow">if</span> ((error = tire_pressure_element.get(tire_pressure))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">        total_tire_pressure += tire_pressure;</div>
<div class="line">    }</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;- Average tire pressure: &quot;</span> &lt;&lt; (total_tire_pressure / 4) &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Writing out all the information about the car</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> field : car) {</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;- &quot;</span> &lt;&lt; field.key &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; field.value &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here is another example:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> abstract_json = R<span class="stringliteral">&quot;( [</span></div>
<div class="line"><span class="stringliteral">    {  &quot;12345&quot; : {&quot;a&quot;:12.34, &quot;b&quot;:56.78, &quot;c&quot;: 9998877}   },</span></div>
<div class="line"><span class="stringliteral">    {  &quot;12545&quot; : {&quot;a&quot;:11.44, &quot;b&quot;:12.78, &quot;c&quot;: 11111111}  }</span></div>
<div class="line"><span class="stringliteral">  ] )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral">dom::parser parser;</span></div>
<div class="line"><span class="stringliteral">dom::array array; </span><span class="comment">// invalid until after the next line</span></div>
<div class="line"><span class="keyword">auto</span> error = parser.parse(abstract_json).get(array);</div>
<div class="line"><span class="keywordflow">if</span> (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line"><span class="comment">// Iterate through an array of objects</span></div>
<div class="line"><span class="keywordflow">for</span> (dom::element elem : array) {</div>
<div class="line">    dom::object obj;</div>
<div class="line">    <span class="keywordflow">if</span> ((error = elem.get(obj))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; key_value : obj) {</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;key: &quot;</span> &lt;&lt; key_value.key &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;</div>
<div class="line">        dom::object innerobj;</div>
<div class="line">        <span class="keywordflow">if</span> ((error = key_value.value.get(innerobj))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> va, vb;</div>
<div class="line">        <span class="keywordflow">if</span> ((error = innerobj[<span class="stringliteral">&quot;a&quot;</span>].get(va))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;a: &quot;</span> &lt;&lt; va &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">        <span class="keywordflow">if</span> ((error = innerobj[<span class="stringliteral">&quot;b&quot;</span>].get(vc))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;b: &quot;</span> &lt;&lt; vb &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        int64_t vc;</div>
<div class="line">        <span class="keywordflow">if</span> ((error = innerobj[<span class="stringliteral">&quot;c&quot;</span>].get(vc))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;c: &quot;</span> &lt;&lt; vc &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And another one:</p>
<div class="fragment"><div class="line">++</div>
<div class="line"> <span class="keyword">auto</span> abstract_json = R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">   {  &quot;str&quot; : { &quot;123&quot; : {&quot;abc&quot; : 3.14 } } } )&quot;_padded;</span></div>
<div class="line"><span class="stringliteral"> dom::parser parser;</span></div>
<div class="line"><span class="stringliteral"> </span><span class="keywordtype">double</span> v;</div>
<div class="line"> <span class="keyword">auto</span> error = parser.parse(abstract_json)[<span class="stringliteral">&quot;str&quot;</span>][<span class="stringliteral">&quot;123&quot;</span>][<span class="stringliteral">&quot;abc&quot;</span>].get(v);</div>
<div class="line"> <span class="keywordflow">if</span> (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;number: &quot;</span> &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><p>Notice how we can string several operations (<code>parser.parse(abstract_json)["str"]["123"]["abc"].get(v)</code>) and only check for the error once, a strategy we call <em>error chaining</em>.</p>
<p>The next two functions will take as input a JSON document containing an array with a single element, either a string or a number. They return true upon success.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classsimdjson_1_1dom_1_1parser.html">simdjson::dom::parser</a> parser{};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> parse_double(<span class="keyword">const</span> <span class="keywordtype">char</span> *j, <span class="keywordtype">double</span> &amp;d) {</div>
<div class="line">  <span class="keyword">auto</span> error = parser.parse(j, std::strlen(j))</div>
<div class="line">        .at(0)</div>
<div class="line">        .get(d, error);</div>
<div class="line">  <span class="keywordflow">if</span> (error) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> parse_string(<span class="keyword">const</span> <span class="keywordtype">char</span> *j, std::string &amp;s) {</div>
<div class="line">  std::string_view answer;</div>
<div class="line">  <span class="keyword">auto</span> error = parser.parse(j, strlen(j))</div>
<div class="line">        .at(0)</div>
<div class="line">        .get(answer, error);</div>
<div class="line">  <span class="keywordflow">if</span> (error) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line">  s.assign(answer.data(), answer.size());</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To ensure you don't write any code that uses exceptions, compile with <code>SIMDJSON_EXCEPTIONS=OFF</code>. For example, if including the project via cmake:</p>
<div class="fragment"><div class="line">target_compile_definitions(simdjson PUBLIC SIMDJSON_EXCEPTIONS=OFF)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md62"></a>
Exceptions</h2>
<p>Users more comfortable with an exception flow may choose to directly cast the <code>simdjson_result&lt;T&gt;</code> to the desired type:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">dom::element doc = parser.parse(json); <span class="comment">// Throws an exception if there was an error!</span></div>
</div><!-- fragment --><p>When used this way, a <code>simdjson_error</code> exception will be thrown if an error occurs, preventing the program from continuing if there was an error.</p>
<p>If one is willing to trigger exceptions, it is possible to write simpler code:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="simdjson_8h.html">simdjson.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <a class="code hl_class" href="classsimdjson_1_1dom_1_1parser.html">simdjson::dom::parser</a> parser;</div>
<div class="line">  <a class="code hl_class" href="classsimdjson_1_1dom_1_1element.html">simdjson::dom::element</a> tweets = parser.<a class="code hl_function" href="classsimdjson_1_1dom_1_1parser.html#ac408e4da66b0ac7cf9734aa4973e0093">load</a>(<span class="stringliteral">&quot;twitter.json&quot;</span>);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;ID: &quot;</span> &lt;&lt; tweets[<span class="stringliteral">&quot;statuses&quot;</span>].<a class="code hl_function" href="classsimdjson_1_1dom_1_1element.html#aa8b5798004a859bf922778226b8c1cce">at</a>(0)[<span class="stringliteral">&quot;id&quot;</span>] &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md63"></a>
Tree Walking and JSON Element Types</h1>
<p>Sometimes you don't necessarily have a document with a known type, and are trying to generically inspect or walk over JSON elements. To do that, you can use iterators and the type() method. For example, here's a quick and dirty recursive function that verbosely prints the JSON document as JSON (* ignoring nuances like trailing commas and escaping strings, for brevity's sake):</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> print_json(dom::element element) {</div>
<div class="line">  <span class="keywordflow">switch</span> (element.type()) {</div>
<div class="line">    <span class="keywordflow">case</span> dom::element_type::ARRAY:</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line">      <span class="keywordflow">for</span> (dom::element child : dom::array(element)) {</div>
<div class="line">        print_json(child);</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> dom::element_type::OBJECT:</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;{&quot;</span>;</div>
<div class="line">      <span class="keywordflow">for</span> (dom::key_value_pair field : dom::object(element)) {</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span> &lt;&lt; field.key &lt;&lt; <span class="stringliteral">&quot;\&quot;: &quot;</span>;</div>
<div class="line">        print_json(field.value);</div>
<div class="line">      }</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> dom::element_type::INT64:</div>
<div class="line">      cout &lt;&lt; int64_t(element) &lt;&lt; endl;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> dom::element_type::UINT64:</div>
<div class="line">      cout &lt;&lt; uint64_t(element) &lt;&lt; endl;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> dom::element_type::DOUBLE:</div>
<div class="line">      cout &lt;&lt; double(element) &lt;&lt; endl;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> dom::element_type::STRING:</div>
<div class="line">      cout &lt;&lt; std::string_view(element) &lt;&lt; endl;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> dom::element_type::BOOL:</div>
<div class="line">      cout &lt;&lt; bool(element) &lt;&lt; endl;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> dom::element_type::NULL_VALUE:</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;null&quot;</span> &lt;&lt; endl;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> basics_treewalk_1() {</div>
<div class="line">  dom::parser parser;</div>
<div class="line">  print_json(parser.load(<span class="stringliteral">&quot;twitter.json&quot;</span>));</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md64"></a>
Reusing the parser for maximum efficiency</h1>
<p>If you're using simdjson to parse multiple documents, or in a loop, you should make a parser once and reuse it. The simdjson library will allocate and retain internal buffers between parses, keeping buffers hot in cache and keeping memory allocation and initialization to a minimum. In this manner, you can parse terabytes of JSON data without doing any new allocation.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">dom::parser parser;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This initializes buffers and a document big enough to handle this JSON.</span></div>
<div class="line">dom::element doc = parser.parse(<span class="stringliteral">&quot;[ true, false ]&quot;</span>_padded);</div>
<div class="line">cout &lt;&lt; doc &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This reuses the existing buffers, and reuses and *overwrites* the old document</span></div>
<div class="line">doc = parser.parse(<span class="stringliteral">&quot;[1, 2, 3]&quot;</span>_padded);</div>
<div class="line">cout &lt;&lt; doc &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This also reuses the existing buffers, and reuses and *overwrites* the old document</span></div>
<div class="line">dom::element doc2 = parser.parse(<span class="stringliteral">&quot;true&quot;</span>_padded);</div>
<div class="line"><span class="comment">// Even if you keep the old reference around, doc and doc2 refer to the same document.</span></div>
<div class="line">cout &lt;&lt; doc &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; doc2 &lt;&lt; endl;</div>
</div><!-- fragment --><p>It's not just internal buffers though. The simdjson library reuses the document itself. The dom::element, dom::object and dom::array instances are <em>references</em> to the internal document. You are only <em>borrowing</em> the document from simdjson, which purposely reuses and overwrites it each time you call parse. This prevent wasteful and unnecessary memory allocation in 99% of cases where JSON is just read, used, and converted to native values or thrown away.</p>
<blockquote class="doxtable">
<p>&zwj;<b>You are only borrowing the document from the simdjson parser. Don't keep it long term!</b> </p>
</blockquote>
<p>This is key: don't keep the <code>document&amp;</code>, <code>dom::element</code>, <code>dom::array</code>, <code>dom::object</code> or <code>string_view</code> objects you get back from the API. Convert them to C++ native values, structs and arrays that you own.</p>
<h1><a class="anchor" id="autotoc_md65"></a>
Server Loops: Long-Running Processes and Memory Capacity</h1>
<p>The simdjson library automatically expands its memory capacity when larger documents are parsed, so that you don't unexpectedly fail. In a short process that reads a bunch of files and then exits, this works pretty flawlessly.</p>
<p>Server loops, though, are long-running processes that will keep the parser around forever. This means that if you encounter a really, really large document, simdjson will not resize back down. The simdjson library lets you adjust your allocation strategy to prevent your server from growing without bound:</p>
<ul>
<li><p class="startli">You can set a <em>max capacity</em> when constructing a parser:</p>
<div class="fragment"><div class="line">++</div>
<div class="line"> dom::parser parser(1000*1000); <span class="comment">// Never grow past documents &gt; 1MB</span></div>
<div class="line"> <span class="keywordflow">for</span> (web_request request : listen()) {</div>
<div class="line">   dom::element doc;</div>
<div class="line">   <span class="keyword">auto</span> error = parser.parse(request.body).get(doc);</div>
<div class="line">   <span class="comment">// If the document was above our limit, emit 413 = payload too large</span></div>
<div class="line">   <span class="keywordflow">if</span> (error == CAPACITY) { request.respond(413); <span class="keywordflow">continue</span>; }</div>
<div class="line">   <span class="comment">// ...</span></div>
<div class="line"> }</div>
</div><!-- fragment --><p class="startli">This parser will grow normally as it encounters larger documents, but will never pass 1MB.</p>
</li>
<li><p class="startli">You can set a <em>fixed capacity</em> that never grows, as well, which can be excellent for predictability and reliability, since simdjson will never call malloc after startup!</p>
<div class="fragment"><div class="line">++</div>
<div class="line"> dom::parser parser(0); <span class="comment">// This parser will refuse to automatically grow capacity</span></div>
<div class="line"> <span class="keyword">auto</span> error = parser.allocate(1000*1000); <span class="comment">// This allocates enough capacity to handle documents &lt;= 1MB</span></div>
<div class="line"> <span class="keywordflow">if</span> (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">for</span> (web_request request : listen()) {</div>
<div class="line">   dom::element doc;</div>
<div class="line">   error = parser.parse(request.body).get(doc);</div>
<div class="line">   <span class="comment">// If the document was above our limit, emit 413 = payload too large</span></div>
<div class="line">   <span class="keywordflow">if</span> (error == CAPACITY) { request.respond(413); <span class="keywordflow">continue</span>; }</div>
<div class="line">   <span class="comment">// ...</span></div>
<div class="line"> }</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md66"></a>
Best Use of the DOM API</h1>
<p>The simdjson API provides access to the JSON DOM (document-object-model) content as a tree of <code>dom::element</code> instances, each representing an object, an array or an atomic type (null, true, false, number). These <code>dom::element</code> instances are lightweight objects (e.g., spanning 16 bytes) and it might be advantageous to pass them by value, as opposed to passing them by reference or by pointer.</p>
<h1><a class="anchor" id="autotoc_md67"></a>
Padding and Temporary Copies</h1>
<p>The simdjson function <code>parser.parse</code> reads data from a padded buffer, containing SIMDJSON_PADDING extra bytes added at the end. If you are passing a <code>padded_string</code> to <code>parser.parse</code> or loading the JSON directly from disk (<code>parser.load</code>), padding is automatically handled. When calling <code>parser.parse</code> on a pointer (e.g., <code>parser.parse(my_char_pointer, my_length_in_bytes)</code>) a temporary copy is made by default with adequate padding and you, again, do not need to be concerned with padding.</p>
<p>Some users may not be able use our <code>padded_string</code> class or to load the data directly from disk (<code>parser.load</code>). They may need to pass data pointers to the library. If these users wish to avoid temporary copies and corresponding temporary memory allocations, they may want to call <code>parser.parse</code> with the <code>realloc_if_needed</code> parameter set to false (e.g., <code>parser.parse(my_char_pointer, my_length_in_bytes, false)</code>). In such cases, they need to ensure that there are at least SIMDJSON_PADDING extra bytes at the end that can be safely accessed and read. They do not need to initialize the padded bytes to any value in particular. The following example is safe:</p>
<p><code>C++ const char *json = R"({"key":"value"})"; const size_t json_len = std::strlen(json); std::unique_ptr&lt;char[]&gt; padded_json_copy{new char[json_len + SIMDJSON_PADDING]}; memcpy(padded_json_copy.get(), json, json_len); memset(padded_json_copy.get() + json_len, 0, SIMDJSON_PADDING); <a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">simdjson::dom::parser</a> parser; <a class="el" href="classsimdjson_1_1dom_1_1element.html" title="A JSON element.">simdjson::dom::element</a> element = parser.parse(padded_json_copy.get(), json_len, false); </code>`</p>
<p>Setting the <code>realloc_if_needed</code> parameter <code>false</code> in this manner may lead to better performance since copies are avoided, but it requires that the user takes more responsibilities: the simdjson library cannot verify that the input buffer was padded with SIMDJSON_PADDING extra bytes.</p>
<h1><a class="anchor" id="autotoc_md68"></a>
Performance Tips</h1>
<ul>
<li>For release builds, we recommend setting <code>NDEBUG</code> pre-processor directive when compiling the <code>simdjson</code> library. Importantly, using the optimization flags <code>-O2</code> or <code>-O3</code> under GCC and LLVM clang does not set the <code>NDEBUG</code> directive, you must set it manually (e.g., <code>-DNDEBUG</code>).</li>
<li>For long streams of JSON documents, consider <a class="el" href="md_doc_2iterate__many.html">`iterate_many`</a> and <a class="el" href="md_doc_2parse__many.html">`parse_many`</a> for better performance. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
